{
  "BigCodeBench/13": {
    "ftplib.FTP": {
      "name": "ftplib.FTP",
      "type": "class",
      "signature": "(host='', user='', passwd='', acct='', timeout=<object object at 0x7f3ef60c4b10>, source_address=None, *, encoding='utf-8')",
      "short_docstring": "An FTP client class.",
      "chains": {
        "quit": {
          "name": "ftplib.FTP.quit",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Quit, and close the connection."
        },
        "nlst": {
          "name": "ftplib.FTP.nlst",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Return a list of files in a given directory (default the current)."
        },
        "cwd": {
          "name": "ftplib.FTP.cwd",
          "type": "callable",
          "signature": "(self, dirname)",
          "short_docstring": "Change to a directory."
        },
        "login": {
          "name": "ftplib.FTP.login",
          "type": "callable",
          "signature": "(self, user='', passwd='')",
          "short_docstring": "Login, default anonymous."
        }
      }
    },
    "downloaded_files.append(filename)": {
      "name": "downloaded_files.append(filename)",
      "error": "Import error: No module named 'downloaded_files'"
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "subprocess.call": {
      "name": "subprocess.call",
      "type": "callable",
      "signature": "(*popenargs, **kwargs)",
      "short_docstring": "Run command with arguments.  Wait for command to complete or\ntimeout, then return the returncode attribute."
    }
  },
  "BigCodeBench/15": {
    "csv.reader": {
      "name": "csv.reader",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_reader = reader(iterable [, dialect='excel']\n                        [optional keyword args])\n    for row in csv_reader:\n        process(row)"
    },
    "open.write(f'\\nError executing command, exited with code {ret_code}')": {
      "name": "open.write(f'\\nError executing command, exited with code {ret_code}')",
      "error": "Import error: No module named 'open'"
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "output_files.append(output_file)": {
      "name": "output_files.append(output_file)",
      "error": "Import error: No module named 'output_files'"
    },
    "subprocess.STDOUT": {
      "name": "subprocess.STDOUT",
      "type": "constant",
      "signature": null,
      "short_docstring": "int([x]) -> integer\nint(x, base=10) -> integer",
      "value": "-2"
    },
    "subprocess.call": {
      "name": "subprocess.call",
      "type": "callable",
      "signature": "(*popenargs, **kwargs)",
      "short_docstring": "Run command with arguments.  Wait for command to complete or\ntimeout, then return the returncode attribute."
    }
  },
  "BigCodeBench/17": {
    "proc.name()": {
      "name": "proc.name()",
      "error": "Import error: No module named 'proc'"
    },
    "proc.terminate()": {
      "name": "proc.terminate()",
      "error": "Import error: No module named 'proc'"
    },
    "psutil.process_iter": {
      "name": "psutil.process_iter",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Return a generator yielding a Process instance for all\nrunning processes."
    },
    "time.sleep": {
      "name": "time.sleep",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sleep(seconds)"
    }
  },
  "BigCodeBench/19": {
    "zipfile.ZipFile": {
      "name": "zipfile.ZipFile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "short_docstring": "Class with methods to open, read, write, close, list zip files.",
      "chains": {
        "write": {
          "name": "zipfile.ZipFile.write",
          "type": "callable",
          "signature": "(self, filename, arcname=None)",
          "short_docstring": "Put the bytes from filename into the archive under the name\narcname."
        }
      }
    },
    "glob.glob": {
      "name": "glob.glob",
      "type": "callable",
      "signature": "(pathname)",
      "short_docstring": "Return a list of paths matching a pathname pattern."
    },
    "os.path.isfile": {
      "name": "os.path.isfile",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path is a regular file"
    },
    "os.path.basename": {
      "name": "os.path.basename",
      "type": "callable",
      "signature": "(p)",
      "short_docstring": "Returns the final component of a pathname"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    }
  },
  "BigCodeBench/34": {
    "matplotlib.pyplot.axis": {
      "name": "matplotlib.pyplot.axis",
      "type": "callable",
      "signature": "(arg=None)",
      "short_docstring": "Convenience method to get or set some axis properties."
    },
    "matplotlib.pyplot.imshow": {
      "name": "matplotlib.pyplot.imshow",
      "type": "callable",
      "signature": "(X)",
      "short_docstring": "Display data as an image, i.e., on a 2D regular raster."
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "(figsize=None, **kwargs)",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "re.sub.strip": {
      "name": "re.sub.strip",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used."
    },
    "re.sub": {
      "name": "re.sub",
      "type": "callable",
      "signature": "(pattern, repl, string)",
      "short_docstring": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used."
    }
  },
  "BigCodeBench/37": {
    "RandomForestClassifier(random_state=42).fit.feature_importances_": {
      "name": "RandomForestClassifier(random_state=42).fit.feature_importances_",
      "error": "Import error: No module named 'fit'"
    },
    "df.drop.columns": {
      "name": "df.drop.columns",
      "error": "Import error: No module named 'df'"
    },
    "df.drop(target_column, axis=1)": {
      "name": "df.drop(target_column, axis=1)",
      "error": "Import error: No module named 'df'"
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "(figsize=None, **kwargs)",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "pd.Series(model.feature_importances_, index=X.columns)": {
      "name": "pd.Series(model.feature_importances_, index=X.columns)",
      "error": "Import error: No module named 'pd'"
    },
    "pd.Series(model.feature_importances_, index=X.columns).sort_values.index": {
      "name": "pd.Series(model.feature_importances_, index=X.columns).sort_values.index",
      "error": "Import error: No module named 'sort_values'"
    },
    "seaborn.barplot.set_ylabel": {
      "name": "seaborn.barplot.set_ylabel",
      "type": "callable",
      "signature": "(data=None)",
      "short_docstring": "Show point estimates and errors as rectangular bars."
    },
    "seaborn.barplot": {
      "name": "seaborn.barplot",
      "type": "callable",
      "signature": "(x=None, y=None, **kwargs)",
      "short_docstring": "Show point estimates and errors as rectangular bars."
    },
    "seaborn.barplot.set_xlabel": {
      "name": "seaborn.barplot.set_xlabel",
      "type": "callable",
      "signature": "(data=None)",
      "short_docstring": "Show point estimates and errors as rectangular bars."
    },
    "seaborn.barplot.set_title": {
      "name": "seaborn.barplot.set_title",
      "type": "callable",
      "signature": "(data=None)",
      "short_docstring": "Show point estimates and errors as rectangular bars."
    },
    "sklearn.ensemble.RandomForestClassifier": {
      "name": "sklearn.ensemble.RandomForestClassifier",
      "type": "class",
      "signature": "(random_state=None)",
      "short_docstring": "A random forest classifier."
    }
  },
  "BigCodeBench/82": {
    "flask.Flask": {
      "name": "flask.Flask",
      "type": "class",
      "signature": "(import_name: 'str', static_url_path: 'str | None' = None, static_folder: 'str | os.PathLike[str] | None' = 'static', static_host: 'str | None' = None, host_matching: 'bool' = False, subdomain_matching: 'bool' = False, template_folder: 'str | os.PathLike[str] | None' = 'templates', instance_path: 'str | None' = None, instance_relative_config: 'bool' = False, root_path: 'str | None' = None)",
      "short_docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more.",
      "chains": {
        "config": {
          "name": "flask.Flask.config",
          "type": "class",
          "signature": "(import_name: 'str', static_url_path: 'str | None' = None, static_folder: 'str | os.PathLike[str] | None' = 'static', static_host: 'str | None' = None, host_matching: 'bool' = False, subdomain_matching: 'bool' = False, template_folder: 'str | os.PathLike[str] | None' = 'templates', instance_path: 'str | None' = None, instance_relative_config: 'bool' = False, root_path: 'str | None' = None)",
          "short_docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more."
        },
        "route": {
          "name": "flask.Flask.route",
          "type": "callable",
          "signature": "(self, rule: 'str')",
          "short_docstring": "Decorate a view function to register it with the given URL\nrule and options. Calls :meth:`add_url_rule`, which has more\ndetails about the implementation."
        }
      }
    },
    "flask_login.UserMixin": {
      "name": "flask_login.UserMixin",
      "type": "class",
      "signature": "()",
      "short_docstring": "This provides default implementations for the methods that Flask-Login\nexpects user objects to have.",
      "chains": {
        "id": {
          "name": "flask_login.UserMixin.id",
          "type": "class",
          "signature": "()",
          "short_docstring": "This provides default implementations for the methods that Flask-Login\nexpects user objects to have."
        },
        "password_hash": {
          "name": "flask_login.UserMixin.password_hash",
          "type": "class",
          "signature": "()",
          "short_docstring": "This provides default implementations for the methods that Flask-Login\nexpects user objects to have."
        }
      }
    },
    "flask_login.LoginManager": {
      "name": "flask_login.LoginManager",
      "type": "class",
      "signature": "(app=None, add_context_processor=True)",
      "short_docstring": "This object is used to hold the settings used for logging in. Instances\nof :class:`LoginManager` are *not* bound to specific apps, so you can\ncreate one in the main body of your code and then bind it to your\napp in a factory function.",
      "chains": {
        "user_loader": {
          "name": "flask_login.LoginManager.user_loader",
          "type": "callable",
          "signature": "(self, callback)",
          "short_docstring": "This sets the callback for reloading a user from the session. The\nfunction you set should take a user ID (a ``str``) and return a\nuser object, or ``None`` if the user does not exist."
        },
        "init_app": {
          "name": "flask_login.LoginManager.init_app",
          "type": "callable",
          "signature": "(self, app)",
          "short_docstring": "Configures an application. This registers an `after_request` call, and\nattaches this `LoginManager` to it as `app.login_manager`."
        }
      }
    },
    "LoginForm.password": {
      "name": "LoginForm.password",
      "error": "Import error: No module named 'LoginForm'"
    },
    "LoginForm.username": {
      "name": "LoginForm.username",
      "error": "Import error: No module named 'LoginForm'"
    },
    "LoginForm.username.data": {
      "name": "LoginForm.username.data",
      "error": "Import error: No module named 'LoginForm'"
    },
    "LoginForm.password.data": {
      "name": "LoginForm.password.data",
      "error": "Import error: No module named 'LoginForm'"
    },
    "LoginForm.validate_on_submit()": {
      "name": "LoginForm.validate_on_submit()",
      "error": "Import error: No module named 'LoginForm'"
    },
    "flask.url_for": {
      "name": "flask.url_for",
      "type": "callable",
      "signature": "(endpoint: 'str')",
      "short_docstring": "Generate a URL to the given endpoint with the given values."
    },
    "flask.redirect": {
      "name": "flask.redirect",
      "type": "callable",
      "signature": "(location: 'str')",
      "short_docstring": "Create a redirect response object."
    },
    "flask.render_template": {
      "name": "flask.render_template",
      "type": "callable",
      "signature": "(template_name_or_list: 'str | Template | list[str | Template]')",
      "short_docstring": "Render a template by name with the given context."
    },
    "flask_login.logout_user": {
      "name": "flask_login.logout_user",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Logs a user out. (You do not need to pass the actual user.) This will\nalso clean up the remember me cookie if it exists."
    },
    "flask_login.current_user.id": {
      "name": "flask_login.current_user.id",
      "type": "callable",
      "signature": "(self, *args, **kwargs)",
      "short_docstring": ""
    },
    "flask_login.login_user": {
      "name": "flask_login.login_user",
      "type": "callable",
      "signature": "(user)",
      "short_docstring": "Logs a user in. You should pass the actual user object to this. If the\nuser's `is_active` property is ``False``, they will not be logged in\nunless `force` is ``True``."
    },
    "werkzeug.security.generate_password_hash": {
      "name": "werkzeug.security.generate_password_hash",
      "type": "callable",
      "signature": "(password: 'str')",
      "short_docstring": "Securely hash a password for storage. A password can be compared to a stored hash\nusing :func:`check_password_hash`."
    },
    "werkzeug.security.check_password_hash": {
      "name": "werkzeug.security.check_password_hash",
      "type": "callable",
      "signature": "(pwhash: 'str', password: 'str') -> 'bool)",
      "short_docstring": "Securely check that the given stored password hash, previously generated using\n:func:`generate_password_hash`, matches the given password."
    },
    "wtforms.validators.DataRequired": {
      "name": "wtforms.validators.DataRequired",
      "type": "class",
      "signature": "()",
      "short_docstring": "Checks the field's data is 'truthy' otherwise stops the validation chain."
    },
    "wtforms.validators.Length": {
      "name": "wtforms.validators.Length",
      "type": "class",
      "signature": "(min=-1, max=-1)",
      "short_docstring": "Validates the length of a string."
    }
  },
  "BigCodeBench/89": {
    "column_data.reshape(-1, 1)": {
      "name": "column_data.reshape(-1, 1)",
      "error": "Import error: No module named 'column_data'"
    },
    "matplotlib.pyplot.show": {
      "name": "matplotlib.pyplot.show",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Display all open figures."
    },
    "matplotlib.pyplot.subplot": {
      "name": "matplotlib.pyplot.subplot",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Add an Axes to the current figure or retrieve an existing Axes."
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "(figsize=None, **kwargs)",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "matplotlib.pyplot.title": {
      "name": "matplotlib.pyplot.title",
      "type": "callable",
      "signature": "(label)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.scatter": {
      "name": "matplotlib.pyplot.scatter",
      "type": "callable",
      "signature": "(x, y)",
      "short_docstring": "A scatter plot of *y* vs. *x* with varying marker size and/or color."
    },
    "numpy.copy": {
      "name": "numpy.copy",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Return an array copy of the given object."
    },
    "numpy.where": {
      "name": "numpy.where",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "where(condition, [x, y])"
    },
    "numpy.delete": {
      "name": "numpy.delete",
      "type": "callable",
      "signature": "(arr, obj, axis=None)",
      "short_docstring": "Return a new array with sub-arrays along an axis deleted. For a one\ndimensional array, this returns those entries not returned by\n`arr[obj]`."
    },
    "numpy.abs": {
      "name": "numpy.abs",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "scipy.stats.zscore": {
      "name": "scipy.stats.zscore",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the z score."
    },
    "sklearn.preprocessing.StandardScaler": {
      "name": "sklearn.preprocessing.StandardScaler",
      "type": "class",
      "signature": "()",
      "short_docstring": "Standardize features by removing the mean and scaling to unit variance."
    },
    "sklearn.preprocessing.StandardScaler.fit_transform": {
      "name": "sklearn.preprocessing.StandardScaler.fit_transform",
      "type": "callable",
      "signature": "(self, X)",
      "short_docstring": "Fit to data, then transform it."
    }
  },
  "BigCodeBench/92": {
    "data.iloc": {
      "name": "data.iloc",
      "error": "Import error: No module named 'data'"
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].scatter": {
      "name": "matplotlib.pyplot.subplots[1].scatter",
      "type": "method",
      "signature": "(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)",
      "short_docstring": "A scatter plot of *y* vs. *x* with varying marker size and/or color."
    },
    "sklearn.cluster.KMeans.cluster_centers_": {
      "name": "sklearn.cluster.KMeans.cluster_centers_",
      "type": "class",
      "signature": "(n_clusters=8, *, init='k-means++', n_init='warn', max_iter=300, tol=0.0001, verbose=0, random_state=None, copy_x=True, algorithm='lloyd')",
      "short_docstring": "K-Means clustering."
    },
    "sklearn.cluster.KMeans.fit_predict": {
      "name": "sklearn.cluster.KMeans.fit_predict",
      "type": "callable",
      "signature": "(self, X)",
      "short_docstring": "Compute cluster centers and predict cluster index for each sample."
    },
    "sklearn.cluster.KMeans": {
      "name": "sklearn.cluster.KMeans",
      "type": "class",
      "signature": "(n_clusters=8)",
      "short_docstring": "K-Means clustering."
    }
  },
  "BigCodeBench/93": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].scatter": {
      "name": "matplotlib.pyplot.subplots[1].scatter",
      "type": "method",
      "signature": "(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)",
      "short_docstring": "A scatter plot of *y* vs. *x* with varying marker size and/or color."
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "sklearn.decomposition.PCA.fit_transform": {
      "name": "sklearn.decomposition.PCA.fit_transform",
      "type": "callable",
      "signature": "(self, X)",
      "short_docstring": "Fit the model with X and apply the dimensionality reduction on X."
    },
    "sklearn.decomposition.PCA": {
      "name": "sklearn.decomposition.PCA",
      "type": "class",
      "signature": "(n_components=None)",
      "short_docstring": "Principal component analysis (PCA)."
    }
  },
  "BigCodeBench/99": {
    "matplotlib.pyplot.rc": {
      "name": "matplotlib.pyplot.rc",
      "type": "callable",
      "signature": "(group, **kwargs)",
      "short_docstring": "Set the current `.rcParams`.  *group* is the grouping for the rc, e.g.,\nfor ``lines.linewidth`` the group is ``lines``, for\n``axes.facecolor``, the group is ``axes``, and so on.  Group may\nalso be a list or tuple of group names, e.g., (*xtick*, *ytick*).\n*kwargs* is a dictionary attribute name/value pairs, e.g.,::"
    },
    "seaborn.pairplot.fig": {
      "name": "seaborn.pairplot.fig",
      "type": "callable",
      "signature": "(data, *, hue=None, hue_order=None, palette=None, vars=None, x_vars=None, y_vars=None, kind='scatter', diag_kind='auto', markers=None, height=2.5, aspect=1, corner=False, dropna=False, plot_kws=None, diag_kws=None, grid_kws=None, size=None)",
      "short_docstring": "Plot pairwise relationships in a dataset."
    },
    "seaborn.pairplot": {
      "name": "seaborn.pairplot",
      "type": "callable",
      "signature": "(data, hue=None, vars=None)",
      "short_docstring": "Plot pairwise relationships in a dataset."
    },
    "seaborn.pairplot.fig.suptitle": {
      "name": "seaborn.pairplot.fig.suptitle",
      "type": "callable",
      "signature": "(data)",
      "short_docstring": "Plot pairwise relationships in a dataset."
    },
    "sklearn.datasets.load_iris": {
      "name": "sklearn.datasets.load_iris",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Load and return the iris dataset (classification)."
    },
    "sklearn.datasets.load_iris.data": {
      "name": "sklearn.datasets.load_iris.data",
      "type": "callable",
      "signature": "(*, return_X_y=False, as_frame=False)",
      "short_docstring": "Load and return the iris dataset (classification)."
    },
    "sklearn.datasets.load_iris.target": {
      "name": "sklearn.datasets.load_iris.target",
      "type": "callable",
      "signature": "(*, return_X_y=False, as_frame=False)",
      "short_docstring": "Load and return the iris dataset (classification)."
    },
    "sklearn.datasets.load_iris.feature_names": {
      "name": "sklearn.datasets.load_iris.feature_names",
      "type": "callable",
      "signature": "(*, return_X_y=False, as_frame=False)",
      "short_docstring": "Load and return the iris dataset (classification)."
    }
  },
  "BigCodeBench/100": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.rc": {
      "name": "matplotlib.pyplot.rc",
      "type": "callable",
      "signature": "(group, **kwargs)",
      "short_docstring": "Set the current `.rcParams`.  *group* is the grouping for the rc, e.g.,\nfor ``lines.linewidth`` the group is ``lines``, for\n``axes.facecolor``, the group is ``axes``, and so on.  Group may\nalso be a list or tuple of group names, e.g., (*xtick*, *ytick*).\n*kwargs* is a dictionary attribute name/value pairs, e.g.,::"
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "pandas.date_range": {
      "name": "pandas.date_range",
      "type": "callable",
      "signature": "(end=None, periods=None, **kwargs) -> 'DatetimeIndex)",
      "short_docstring": "Return a fixed frequency DatetimeIndex."
    },
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    }
  },
  "BigCodeBench/101": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "corr": {
          "name": "pandas.DataFrame.corr",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Compute pairwise correlation of columns, excluding NA/null values."
        }
      }
    },
    "matplotlib.pyplot.rc('font', None=font)": {
      "name": "matplotlib.pyplot.rc('font', None=font)",
      "error": "expression cannot contain assignment, perhaps you meant \"==\"? (<unknown>, line 1)"
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "(figsize=None, **kwargs)",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "numpy.hstack": {
      "name": "numpy.hstack",
      "type": "callable",
      "signature": "(tup)",
      "short_docstring": "Stack arrays in sequence horizontally (column wise)."
    },
    "pandas.read_csv.values": {
      "name": "pandas.read_csv.values",
      "type": "callable",
      "signature": "(filepath_or_buffer: 'FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]', *, sep: 'str | None | lib.NoDefault' = <no_default>, delimiter: 'str | None | lib.NoDefault' = None, header: \"int | Sequence[int] | None | Literal['infer']\" = 'infer', names: 'Sequence[Hashable] | None | lib.NoDefault' = <no_default>, index_col: 'IndexLabel | Literal[False] | None' = None, usecols=None, dtype: 'DtypeArg | None' = None, engine: 'CSVEngine | None' = None, converters=None, true_values=None, false_values=None, skipinitialspace: 'bool' = False, skiprows=None, skipfooter: 'int' = 0, nrows: 'int | None' = None, na_values=None, keep_default_na: 'bool' = True, na_filter: 'bool' = True, verbose: 'bool' = False, skip_blank_lines: 'bool' = True, parse_dates: 'bool | Sequence[Hashable] | None' = None, infer_datetime_format: 'bool | lib.NoDefault' = <no_default>, keep_date_col: 'bool' = False, date_parser=<no_default>, date_format: 'str | None' = None, dayfirst: 'bool' = False, cache_dates: 'bool' = True, iterator: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', thousands: 'str | None' = None, decimal: 'str' = '.', lineterminator: 'str | None' = None, quotechar: 'str' = '\"', quoting: 'int' = 0, doublequote: 'bool' = True, escapechar: 'str | None' = None, comment: 'str | None' = None, encoding: 'str | None' = None, encoding_errors: 'str | None' = 'strict', dialect: 'str | csv.Dialect | None' = None, on_bad_lines: 'str' = 'error', delim_whitespace: 'bool' = False, low_memory=True, memory_map: 'bool' = False, float_precision: \"Literal['high', 'legacy'] | None\" = None, storage_options: 'StorageOptions' = None, dtype_backend: 'DtypeBackend | lib.NoDefault' = <no_default>) -> 'DataFrame | TextFileReader'",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "pandas.read_csv": {
      "name": "pandas.read_csv",
      "type": "callable",
      "signature": "(filepath_or_buffer: 'FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]', sep: 'str | None | lib.NoDefault' = <no_default>, header: \"int | Sequence[int] | None | Literal['infer']\" = 'infer', skiprows=None)",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "seaborn.set_theme": {
      "name": "seaborn.set_theme",
      "type": "callable",
      "signature": "(style='darkgrid')",
      "short_docstring": "Set aspects of the visual theme for all matplotlib and seaborn plots."
    },
    "seaborn.heatmap": {
      "name": "seaborn.heatmap",
      "type": "callable",
      "signature": "(data, annot=None, **kwargs)",
      "short_docstring": "Plot rectangular data as a color-encoded matrix."
    }
  },
  "BigCodeBench/108": {
    "df.columns": {
      "name": "df.columns",
      "error": "Import error: No module named 'df'"
    },
    "df.asfreq.plot(y='value')": {
      "name": "df.asfreq.plot(y='value')",
      "error": "Import error: No module named 'df'"
    },
    "df.set_index.set_index('date')": {
      "name": "df.set_index.set_index('date')",
      "error": "Import error: No module named 'df'"
    },
    "df.asfreq.asfreq(freq, method='pad')": {
      "name": "df.asfreq.asfreq(freq, method='pad')",
      "error": "Import error: No module named 'df'"
    },
    "matplotlib.pyplot.ylabel": {
      "name": "matplotlib.pyplot.ylabel",
      "type": "callable",
      "signature": "(ylabel)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.title": {
      "name": "matplotlib.pyplot.title",
      "type": "callable",
      "signature": "(label)",
      "short_docstring": "Set a title for the Axes."
    },
    "pandas.to_numeric": {
      "name": "pandas.to_numeric",
      "type": "callable",
      "signature": "(arg, errors: 'DateTimeErrorChoices' = 'raise')",
      "short_docstring": "Convert argument to a numeric type."
    },
    "statsmodels.tsa.seasonal.seasonal_decompose": {
      "name": "statsmodels.tsa.seasonal.seasonal_decompose",
      "type": "callable",
      "signature": "(x, model='additive')",
      "short_docstring": "Seasonal decomposition using moving averages."
    }
  },
  "BigCodeBench/120": {
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    }
  },
  "BigCodeBench/123": {
    "glob.glob": {
      "name": "glob.glob",
      "type": "callable",
      "signature": "(pathname)",
      "short_docstring": "Return a list of paths matching a pathname pattern."
    },
    "my_list.append(12)": {
      "name": "my_list.append(12)",
      "error": "Import error: No module named 'my_list'"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "pandas.read_csv": {
      "name": "pandas.read_csv",
      "type": "callable",
      "signature": "(filepath_or_buffer: 'FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]')",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "pandas.concat": {
      "name": "pandas.concat",
      "type": "callable",
      "signature": "(objs: 'Iterable[NDFrame] | Mapping[HashableT, ignore_index: 'bool' = False)",
      "short_docstring": "Concatenate pandas objects along a particular axis."
    }
  },
  "BigCodeBench/124": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].hist": {
      "name": "matplotlib.pyplot.subplots[1].hist",
      "type": "method",
      "signature": "(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)",
      "short_docstring": "Compute and plot a histogram."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "my_list.append(12)": {
      "name": "my_list.append(12)",
      "error": "Import error: No module named 'my_list'"
    },
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    },
    "time.time": {
      "name": "time.time",
      "type": "callable",
      "signature": "()",
      "short_docstring": "time() -> floating point number"
    }
  },
  "BigCodeBench/129": {
    "bs4.BeautifulSoup": {
      "name": "bs4.BeautifulSoup",
      "type": "class",
      "signature": "(markup='', features=None, builder=None, parse_only=None, from_encoding=None, exclude_encodings=None, element_classes=None, **kwargs)",
      "short_docstring": "A data structure representing a parsed HTML or XML document.",
      "chains": {
        "find": {
          "name": "bs4.BeautifulSoup.find",
          "type": "callable",
          "signature": "(self, name=None)",
          "short_docstring": "Look in the children of this PageElement and find the first\nPageElement that matches the given criteria."
        }
      }
    },
    "data.append(cols)": {
      "name": "data.append(cols)",
      "error": "Import error: No module named 'data'"
    },
    "ele.text": {
      "name": "ele.text",
      "error": "Import error: No module named 'ele'"
    },
    "ele.text.strip()": {
      "name": "ele.text.strip()",
      "error": "Import error: No module named 'ele'"
    },
    "requests.get.text": {
      "name": "requests.get.text",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get.raise_for_status": {
      "name": "requests.get.raise_for_status",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Sends a GET request."
    },
    "row.find_all('td')": {
      "name": "row.find_all('td')",
      "error": "Import error: No module named 'row'"
    },
    "soup.find.find_all('tr')": {
      "name": "soup.find.find_all('tr')",
      "error": "Import error: No module named 'soup'"
    },
    "soup.find.find_all('th')": {
      "name": "soup.find.find_all('th')",
      "error": "Import error: No module named 'soup'"
    },
    "th.text": {
      "name": "th.text",
      "error": "Import error: No module named 'th'"
    },
    "th.text.strip()": {
      "name": "th.text.strip()",
      "error": "Import error: No module named 'th'"
    }
  },
  "BigCodeBench/139": {
    "axes.append(ax)": {
      "name": "axes.append(ax)",
      "error": "Import error: No module named 'axes'"
    },
    "df.empty": {
      "name": "df.empty",
      "error": "Import error: No module named 'df'"
    },
    "df.select_dtypes(include=np.number)": {
      "name": "df.select_dtypes(include=np.number)",
      "error": "Import error: No module named 'df'"
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "numeric_cols.size": {
      "name": "numeric_cols.size",
      "error": "Import error: No module named 'numeric_cols'"
    }
  },
  "BigCodeBench/147": {
    "socket.socket": {
      "name": "socket.socket",
      "type": "class",
      "signature": "(family=-1, type=-1, proto=-1, fileno=None)",
      "short_docstring": "A subclass of _socket.socket adding the makefile() method.",
      "chains": {
        "close": {
          "name": "socket.socket.close",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "close()"
        },
        "settimeout": {
          "name": "socket.socket.settimeout",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "settimeout(timeout)"
        },
        "connect": {
          "name": "socket.socket.connect",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "connect(address)"
        }
      }
    },
    "threading.Thread": {
      "name": "threading.Thread",
      "type": "class",
      "signature": "(group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None)",
      "short_docstring": "A class that represents a thread of control.",
      "chains": {
        "join": {
          "name": "threading.Thread.join",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Wait until the thread terminates."
        },
        "start": {
          "name": "threading.Thread.start",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Start the thread's activity."
        }
      }
    },
    "socket.AF_INET": {
      "name": "socket.AF_INET",
      "type": "constant",
      "signature": null,
      "short_docstring": "An enumeration.",
      "value": "AddressFamily.AF_INET"
    },
    "socket.SOCK_STREAM": {
      "name": "socket.SOCK_STREAM",
      "type": "constant",
      "signature": null,
      "short_docstring": "An enumeration.",
      "value": "SocketKind.SOCK_STREAM"
    },
    "threads.append(thread)": {
      "name": "threads.append(thread)",
      "error": "Import error: No module named 'threads'"
    }
  },
  "BigCodeBench/161": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "strptime": {
          "name": "datetime.datetime.strptime",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "string, format -> new datetime parsed from a string (like time.strptime())."
        }
      }
    },
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "to_csv": {
          "name": "pandas.DataFrame.to_csv",
          "type": "callable",
          "signature": "(self, path_or_buf: 'FilePath | WriteBuffer[bytes] | WriteBuffer[str] | None' = None, index: 'bool_t' = True)",
          "short_docstring": "Write object to a comma-separated values (csv) file."
        }
      }
    },
    "line.strip.strip()": {
      "name": "line.strip.strip()",
      "error": "Import error: No module named 'line'"
    },
    "match.groups[2].strip": {
      "name": "match.groups[2].strip",
      "error": "No module named 'match'"
    },
    "parsed_data.append([log_type, timestamp, message.strip()])": {
      "name": "parsed_data.append([log_type, timestamp, message.strip()])",
      "error": "Import error: No module named 'parsed_data'"
    },
    "re.match.groups": {
      "name": "re.match.groups",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Try to apply the pattern at the start of the string, returning\na Match object, or None if no match was found."
    },
    "re.match": {
      "name": "re.match",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Try to apply the pattern at the start of the string, returning\na Match object, or None if no match was found."
    }
  },
  "BigCodeBench/162": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].hist": {
      "name": "matplotlib.pyplot.subplots[1].hist",
      "type": "method",
      "signature": "(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)",
      "short_docstring": "Compute and plot a histogram."
    },
    "numpy.arange": {
      "name": "numpy.arange",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "arange([start,] stop[, step,], dtype=None, *, like=None)"
    },
    "re.split": {
      "name": "re.split",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Split the source string by the occurrences of the pattern,\nreturning a list containing the resulting substrings.  If\ncapturing parentheses are used in pattern, then the text of all\ngroups in the pattern are also returned as part of the resulting\nlist.  If maxsplit is nonzero, at most maxsplit splits occur,\nand the remainder of the string is returned as the final element\nof the list."
    }
  },
  "BigCodeBench/177": {
    "df.columns": {
      "name": "df.columns",
      "error": "Import error: No module named 'df'"
    },
    "interesting_articles.empty": {
      "name": "interesting_articles.empty",
      "error": "Import error: No module named 'interesting_articles'"
    },
    "nltk.word_tokenize": {
      "name": "nltk.word_tokenize",
      "type": "callable",
      "signature": "(text)",
      "short_docstring": "Return a tokenized copy of *text*,\nusing NLTK's recommended word tokenizer\n(currently an improved :class:`.TreebankWordTokenizer`\nalong with :class:`.PunktSentenceTokenizer`\nfor the specified language)."
    },
    "re.IGNORECASE": {
      "name": "re.IGNORECASE",
      "type": "constant",
      "signature": null,
      "short_docstring": "An enumeration.",
      "value": "re.IGNORECASE"
    },
    "re.compile.search": {
      "name": "re.compile.search",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    },
    "re.compile": {
      "name": "re.compile",
      "type": "callable",
      "signature": "(pattern, flags=0)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    }
  },
  "BigCodeBench/184": {
    "' '.join.split()": {
      "name": "' '.join.split()",
      "error": "Import error: No module named 'join'"
    },
    "re.sub": {
      "name": "re.sub",
      "type": "callable",
      "signature": "(pattern, repl, string)",
      "short_docstring": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used."
    },
    "sklearn.feature_extraction.text.CountVectorizer": {
      "name": "sklearn.feature_extraction.text.CountVectorizer",
      "type": "class",
      "signature": "()",
      "short_docstring": "Convert a collection of text documents to a matrix of token counts."
    },
    "sklearn.feature_extraction.text.CountVectorizer.get_feature_names_out": {
      "name": "sklearn.feature_extraction.text.CountVectorizer.get_feature_names_out",
      "type": "callable",
      "signature": "(self)",
      "short_docstring": "Get output feature names for transformation."
    },
    "sklearn.feature_extraction.text.CountVectorizer.fit_transform": {
      "name": "sklearn.feature_extraction.text.CountVectorizer.fit_transform",
      "type": "callable",
      "signature": "(self, raw_documents)",
      "short_docstring": "Learn the vocabulary dictionary and return document-term matrix."
    },
    "text.lower.lower()": {
      "name": "text.lower.lower()",
      "error": "Import error: No module named 'text'"
    },
    "vectorizer.fit_transform.toarray()": {
      "name": "vectorizer.fit_transform.toarray()",
      "error": "Import error: No module named 'vectorizer'"
    }
  },
  "BigCodeBench/187": {
    "numpy.random.uniform": {
      "name": "numpy.random.uniform",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "uniform(low=0.0, high=1.0, size=None)"
    },
    "shapely.geometry.Point": {
      "name": "shapely.geometry.Point",
      "type": "class",
      "signature": "(*args)",
      "short_docstring": "A geometry type that represents a single coordinate with\nx,y and possibly z values."
    }
  },
  "BigCodeBench/199": {
    "pytz.timezone": {
      "name": "pytz.timezone",
      "type": "callable",
      "signature": "(zone)",
      "short_docstring": "Return a datetime.tzinfo implementation for the given timezone"
    },
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    },
    "report_data.append([city, city_time.strftime('%Y-%m-%d %H:%M:%S %Z'), weather])": {
      "name": "report_data.append([city, city_time.strftime('%Y-%m-%d %H:%M:%S %Z'), weather])",
      "error": "Import error: No module named 'report_data'"
    },
    "utc_datetime.astimezone(city_tz)": {
      "name": "utc_datetime.astimezone(city_tz)",
      "error": "Import error: No module named 'utc_datetime'"
    },
    "utc_datetime.astimezone.strftime('%Y-%m-%d %H:%M:%S %Z')": {
      "name": "utc_datetime.astimezone.strftime('%Y-%m-%d %H:%M:%S %Z')",
      "error": "Import error: No module named 'utc_datetime'"
    }
  },
  "BigCodeBench/208": {
    "matplotlib.pyplot.gca": {
      "name": "matplotlib.pyplot.gca",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "matplotlib.pyplot.plot": {
      "name": "matplotlib.pyplot.plot",
      "type": "callable",
      "signature": "(*args)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "matplotlib.pyplot.title": {
      "name": "matplotlib.pyplot.title",
      "type": "callable",
      "signature": "(label)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "(figsize=None, **kwargs)",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "numpy.cumsum": {
      "name": "numpy.cumsum",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Return the cumulative sum of the elements along a given axis."
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "numpy.random.choice": {
      "name": "numpy.random.choice",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "choice(a, size=None, replace=True, p=None)"
    }
  },
  "BigCodeBench/211": {
    "zipfile.ZipFile": {
      "name": "zipfile.ZipFile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "short_docstring": "Class with methods to open, read, write, close, list zip files.",
      "chains": {
        "extractall": {
          "name": "zipfile.ZipFile.extractall",
          "type": "callable",
          "signature": "(self, path=None)",
          "short_docstring": "Extract all members from the archive to the current working\ndirectory. `path' specifies a different directory to extract to.\n`members' is optional and must be a subset of the list returned\nby namelist()."
        }
      }
    },
    "open.write(response.content)": {
      "name": "open.write(response.content)",
      "error": "Import error: No module named 'open'"
    },
    "os.path.basename": {
      "name": "os.path.basename",
      "type": "callable",
      "signature": "(p)",
      "short_docstring": "Returns the final component of a pathname"
    },
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "requests.get.content": {
      "name": "requests.get.content",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url, **kwargs)",
      "short_docstring": "Sends a GET request."
    }
  },
  "BigCodeBench/214": {
    "cv2.COLOR_BGR2RGB": {
      "name": "cv2.COLOR_BGR2RGB",
      "type": "constant",
      "signature": null,
      "short_docstring": "int([x]) -> integer\nint(x, base=10) -> integer",
      "value": "4"
    },
    "cv2.cvtColor": {
      "name": "cv2.cvtColor",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "cvtColor(src, code[, dst[, dstCn]]) -> dst\n.   @brief Converts an image from one color space to another.\n.   \n.   The function converts an input image from one color space to another. In case of a transformation\n.   to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note\n.   that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the\n.   bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue\n.   component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and\n.   sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.\n.   \n.   The conventional ranges for R, G, and B channel values are:\n.   -   0 to 255 for CV_8U images\n.   -   0 to 65535 for CV_16U images\n.   -   0 to 1 for CV_32F images\n.   \n.   In case of linear transformations, the range does not matter. But in case of a non-linear\n.   transformation, an input RGB image should be normalized to the proper value range to get the correct\n.   results, for example, for RGB \\f$\\rightarrow\\f$ L\\*u\\*v\\* transformation. For example, if you have a\n.   32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will\n.   have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor ,\n.   you need first to scale the image down:\n.   @code\n.       img *= 1./255;\n.       cvtColor(img, img, COLOR_BGR2Luv);\n.   @endcode\n.   If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many\n.   applications, this will not be noticeable but it is recommended to use 32-bit images in applications\n.   that need the full range of colors or that convert an image before an operation and then convert\n.   back.\n.   \n.   If conversion adds the alpha channel, its value will set to the maximum of corresponding channel\n.   range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.\n.   \n.   @param src input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision\n.   floating-point.\n.   @param dst output image of the same size and depth as src.\n.   @param code color space conversion code (see #ColorConversionCodes).\n.   @param dstCn number of channels in the destination image; if the parameter is 0, the number of the\n.   channels is derived automatically from src and code.\n.   \n.   @see @ref imgproc_color_conversions"
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].imshow": {
      "name": "matplotlib.pyplot.subplots[1].imshow",
      "type": "method",
      "signature": "(X, cmap=None, norm=None, *, aspect=None, interpolation=None, alpha=None, vmin=None, vmax=None, origin=None, extent=None, interpolation_stage=None, filternorm=True, filterrad=4.0, resample=None, url=None, data=None, **kwargs)",
      "short_docstring": "Display data as an image, i.e., on a 2D regular raster."
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "numpy.zeros": {
      "name": "numpy.zeros",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "zeros(shape, dtype=float, order='C', *, like=None)"
    },
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    }
  },
  "BigCodeBench/227": {
    "librosa.stft": {
      "name": "librosa.stft",
      "type": "callable",
      "signature": "(y: numpy.ndarray)",
      "short_docstring": "Short-time Fourier transform (STFT)."
    },
    "librosa.amplitude_to_db": {
      "name": "librosa.amplitude_to_db",
      "type": "callable",
      "signature": "(S: numpy.ndarray, ref: Union[float)",
      "short_docstring": "Convert an amplitude spectrogram to dB-scaled spectrogram."
    },
    "librosa.display.specshow": {
      "name": "librosa.display.specshow",
      "type": "callable",
      "signature": "(data: 'np.ndarray', x_axis: 'Optional[str]' = None, y_axis: 'Optional[str]' = None, sr: 'float' = 22050)",
      "short_docstring": "Display a spectrogram/chromagram/cqt/etc."
    },
    "matplotlib.pyplot.gcf": {
      "name": "matplotlib.pyplot.gcf",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current figure."
    },
    "matplotlib.pyplot.title": {
      "name": "matplotlib.pyplot.title",
      "type": "callable",
      "signature": "(label)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.colorbar": {
      "name": "matplotlib.pyplot.colorbar",
      "type": "callable",
      "signature": "(**kwargs)",
      "short_docstring": "Add a colorbar to a plot."
    },
    "numpy.max": {
      "name": "numpy.max",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Return the maximum of an array or maximum along an axis."
    },
    "numpy.array": {
      "name": "numpy.array",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    },
    "numpy.mean": {
      "name": "numpy.mean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis."
    },
    "numpy.sqrt": {
      "name": "numpy.sqrt",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "numpy.abs": {
      "name": "numpy.abs",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "numpy.log10": {
      "name": "numpy.log10",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "os.path.isfile": {
      "name": "os.path.isfile",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path is a regular file"
    },
    "soundfile.read": {
      "name": "soundfile.read",
      "type": "callable",
      "signature": "(file)",
      "short_docstring": "Provide audio data from a sound file as NumPy array."
    }
  },
  "BigCodeBench/239": {
    "matplotlib.pyplot.close": {
      "name": "matplotlib.pyplot.close",
      "type": "callable",
      "signature": "(fig=None)",
      "short_docstring": "Close a figure window."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].get_xlim": {
      "name": "matplotlib.pyplot.subplots[1].get_xlim",
      "type": "method",
      "signature": "()",
      "short_docstring": "Return the x-axis view limits."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "matplotlib.pyplot.subplots[1].hist": {
      "name": "matplotlib.pyplot.subplots[1].hist",
      "type": "method",
      "signature": "(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)",
      "short_docstring": "Compute and plot a histogram."
    },
    "numpy.max": {
      "name": "numpy.max",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Return the maximum of an array or maximum along an axis."
    },
    "numpy.std": {
      "name": "numpy.std",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the standard deviation along the specified axis."
    },
    "numpy.min": {
      "name": "numpy.min",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Return the minimum of an array or minimum along an axis."
    },
    "numpy.mean": {
      "name": "numpy.mean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis."
    },
    "numpy.linspace": {
      "name": "numpy.linspace",
      "type": "callable",
      "signature": "(start, stop, num=50)",
      "short_docstring": "Return evenly spaced numbers over a specified interval."
    },
    "numpy.array": {
      "name": "numpy.array",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    },
    "scipy.stats.norm": {
      "name": "scipy.stats.norm",
      "type": "callable",
      "signature": "(*args, **kwds)",
      "short_docstring": "A normal continuous random variable."
    },
    "scipy.stats.norm.pdf": {
      "name": "scipy.stats.norm.pdf",
      "type": "callable",
      "signature": "(x, *args, **kwds)",
      "short_docstring": "Probability density function at x of the given RV."
    }
  },
  "BigCodeBench/241": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "numpy.array.size": {
      "name": "numpy.array.size",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    },
    "numpy.array": {
      "name": "numpy.array",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    },
    "sklearn.preprocessing.normalize": {
      "name": "sklearn.preprocessing.normalize",
      "type": "callable",
      "signature": "(X)",
      "short_docstring": "Scale input vectors individually to unit norm (vector length)."
    }
  },
  "BigCodeBench/267": {
    "data.values()": {
      "name": "data.values()",
      "error": "Import error: No module named 'data'"
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "(**fig_kw)",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "numpy.pi": {
      "name": "numpy.pi",
      "type": "constant",
      "signature": null,
      "short_docstring": "Convert a string or number to a floating point number, if possible.",
      "value": "3.141592653589793"
    },
    "numpy.abs": {
      "name": "numpy.abs",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "numpy.outer": {
      "name": "numpy.outer",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Compute the outer product of two vectors."
    },
    "numpy.array": {
      "name": "numpy.array",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    },
    "numpy.sin": {
      "name": "numpy.sin",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "numpy.linspace": {
      "name": "numpy.linspace",
      "type": "callable",
      "signature": "(start, stop, num=50, endpoint=True)",
      "short_docstring": "Return evenly spaced numbers over a specified interval."
    },
    "scipy.fftpack.fft": {
      "name": "scipy.fftpack.fft",
      "type": "callable",
      "signature": "(x)",
      "short_docstring": "Return discrete Fourier transform of real or complex sequence."
    }
  },
  "BigCodeBench/273": {
    "cgi.parse_header": {
      "name": "cgi.parse_header",
      "type": "callable",
      "signature": "(line)",
      "short_docstring": "Parse a Content-type like header."
    },
    "http.server.BaseHTTPRequestHandler": {
      "name": "http.server.BaseHTTPRequestHandler",
      "type": "class",
      "signature": "(request, client_address, server)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.rfile": {
      "name": "http.server.BaseHTTPRequestHandler.rfile",
      "type": "class",
      "signature": "(request, client_address, server)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.wfile": {
      "name": "http.server.BaseHTTPRequestHandler.wfile",
      "type": "class",
      "signature": "(request, client_address, server)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.headers": {
      "name": "http.server.BaseHTTPRequestHandler.headers",
      "type": "class",
      "signature": "(request, client_address, server)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.end_headers": {
      "name": "http.server.BaseHTTPRequestHandler.end_headers",
      "type": "callable",
      "signature": "(self)",
      "short_docstring": "Send the blank line ending the MIME headers."
    },
    "http.server.BaseHTTPRequestHandler.send_response": {
      "name": "http.server.BaseHTTPRequestHandler.send_response",
      "type": "callable",
      "signature": "(self, code)",
      "short_docstring": "Add the response header to the headers buffer and log the\nresponse code."
    },
    "http.server.BaseHTTPRequestHandler.rfile.read": {
      "name": "http.server.BaseHTTPRequestHandler.rfile.read",
      "type": "class",
      "signature": "(request)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.wfile.write": {
      "name": "http.server.BaseHTTPRequestHandler.wfile.write",
      "type": "class",
      "signature": "(request)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.headers.get": {
      "name": "http.server.BaseHTTPRequestHandler.headers.get",
      "type": "class",
      "signature": "(request)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.send_error": {
      "name": "http.server.BaseHTTPRequestHandler.send_error",
      "type": "callable",
      "signature": "(self, code, message=None)",
      "short_docstring": "Send and log an error reply."
    },
    "http.server.BaseHTTPRequestHandler.send_header": {
      "name": "http.server.BaseHTTPRequestHandler.send_header",
      "type": "callable",
      "signature": "(self, keyword, value)",
      "short_docstring": "Send a MIME header to the headers buffer."
    },
    "json.dumps": {
      "name": "json.dumps",
      "type": "callable",
      "signature": "(obj)",
      "short_docstring": "Serialize ``obj`` to a JSON formatted ``str``."
    },
    "json.loads": {
      "name": "json.loads",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object."
    }
  },
  "BigCodeBench/274": {
    "smtplib.SMTP": {
      "name": "smtplib.SMTP",
      "type": "class",
      "signature": "(host='', port=0, local_hostname=None, timeout=<object object at 0x7f3ef60c4b10>, source_address=None)",
      "short_docstring": "This class manages a connection to an SMTP or ESMTP server.\nSMTP Objects:\n    SMTP objects have the following attributes:\n        helo_resp\n            This is the message given by the server in response to the\n            most recent HELO command.",
      "chains": {
        "starttls": {
          "name": "smtplib.SMTP.starttls",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Puts the connection to the SMTP server into TLS mode."
        },
        "login": {
          "name": "smtplib.SMTP.login",
          "type": "callable",
          "signature": "(self, user, password)",
          "short_docstring": "Log in on an SMTP server that requires authentication."
        },
        "sendmail": {
          "name": "smtplib.SMTP.sendmail",
          "type": "callable",
          "signature": "(self, from_addr, to_addrs, msg)",
          "short_docstring": "This command performs an entire mail transaction."
        }
      }
    },
    "cgi.parse_header": {
      "name": "cgi.parse_header",
      "type": "callable",
      "signature": "(line)",
      "short_docstring": "Parse a Content-type like header."
    },
    "email.mime.text.MIMEText.as_string": {
      "name": "email.mime.text.MIMEText.as_string",
      "type": "callable",
      "signature": "(self)",
      "short_docstring": "Return the entire formatted message as a string."
    },
    "email.mime.text.MIMEText": {
      "name": "email.mime.text.MIMEText",
      "type": "class",
      "signature": "(_text)",
      "short_docstring": "Class for generating text/* type MIME documents."
    },
    "http.server.BaseHTTPRequestHandler": {
      "name": "http.server.BaseHTTPRequestHandler",
      "type": "class",
      "signature": "(request, client_address, server)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.rfile": {
      "name": "http.server.BaseHTTPRequestHandler.rfile",
      "type": "class",
      "signature": "(request, client_address, server)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.headers": {
      "name": "http.server.BaseHTTPRequestHandler.headers",
      "type": "class",
      "signature": "(request, client_address, server)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.end_headers": {
      "name": "http.server.BaseHTTPRequestHandler.end_headers",
      "type": "callable",
      "signature": "(self)",
      "short_docstring": "Send the blank line ending the MIME headers."
    },
    "http.server.BaseHTTPRequestHandler.send_response": {
      "name": "http.server.BaseHTTPRequestHandler.send_response",
      "type": "callable",
      "signature": "(self, code)",
      "short_docstring": "Add the response header to the headers buffer and log the\nresponse code."
    },
    "http.server.BaseHTTPRequestHandler.rfile.read": {
      "name": "http.server.BaseHTTPRequestHandler.rfile.read",
      "type": "class",
      "signature": "(request)",
      "short_docstring": "HTTP request handler base class."
    },
    "http.server.BaseHTTPRequestHandler.headers.get": {
      "name": "http.server.BaseHTTPRequestHandler.headers.get",
      "type": "class",
      "signature": "(request)",
      "short_docstring": "HTTP request handler base class."
    },
    "json.loads": {
      "name": "json.loads",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object."
    }
  },
  "BigCodeBench/287": {
    "collections.Counter": {
      "name": "collections.Counter",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "short_docstring": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.",
      "chains": {
        "update": {
          "name": "collections.Counter.update",
          "type": "callable",
          "signature": "(self, iterable=None)",
          "short_docstring": "Like dict.update() but add counts instead of replacing them."
        }
      }
    },
    "file_name.endswith('.txt')": {
      "name": "file_name.endswith('.txt')",
      "error": "Import error: No module named 'file_name'"
    },
    "json.dump": {
      "name": "json.dump",
      "type": "callable",
      "signature": "(obj, fp)",
      "short_docstring": "Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n``.write()``-supporting file-like object)."
    },
    "open.read()": {
      "name": "open.read()",
      "error": "Import error: No module named 'open'"
    },
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    }
  },
  "BigCodeBench/302": {
    "df.index": {
      "name": "df.index",
      "error": "Import error: No module named 'df'"
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "matplotlib.pyplot.title": {
      "name": "matplotlib.pyplot.title",
      "type": "callable",
      "signature": "(label)",
      "short_docstring": "Set a title for the Axes."
    },
    "pandas.concat.iloc": {
      "name": "pandas.concat.iloc",
      "type": "callable",
      "signature": "(objs: 'Iterable[NDFrame] | Mapping[HashableT, NDFrame]', *, axis: 'Axis' = 0, join: 'str' = 'outer', ignore_index: 'bool' = False, keys=None, levels=None, names=None, verify_integrity: 'bool' = False, sort: 'bool' = False, copy: 'bool | None' = None) -> 'DataFrame | Series'",
      "short_docstring": "Concatenate pandas objects along a particular axis."
    },
    "pandas.to_datetime": {
      "name": "pandas.to_datetime",
      "type": "callable",
      "signature": "(arg: 'DatetimeScalarOrArrayConvertible | DictConvertible')",
      "short_docstring": "Convert argument to datetime."
    },
    "pandas.concat": {
      "name": "pandas.concat",
      "type": "callable",
      "signature": "(objs: 'Iterable[NDFrame] | Mapping[HashableT, axis: 'Axis' = 0)",
      "short_docstring": "Concatenate pandas objects along a particular axis."
    },
    "seaborn.heatmap": {
      "name": "seaborn.heatmap",
      "type": "callable",
      "signature": "(data, cmap=None, annot=None, **kwargs)",
      "short_docstring": "Plot rectangular data as a color-encoded matrix."
    }
  },
  "BigCodeBench/308": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "loc": {
          "name": "pandas.DataFrame.loc",
          "type": "constant",
          "signature": null,
          "short_docstring": "Access a group of rows and columns by label(s) or a boolean array.",
          "value": "<property object at 0x7f3e4789d620>"
        },
        "apply": {
          "name": "pandas.DataFrame.apply",
          "type": "callable",
          "signature": "(self, func: 'AggFuncType', axis: 'Axis' = 0, **kwargs)",
          "short_docstring": "Apply a function along an axis of the DataFrame."
        }
      }
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    },
    "statistics.mean": {
      "name": "statistics.mean",
      "type": "callable",
      "signature": "(data)",
      "short_docstring": "Return the sample arithmetic mean of data."
    }
  },
  "BigCodeBench/310": {
    "csv.writer": {
      "name": "csv.writer",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerows": {
      "name": "csv.writer.writerows",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerow": {
      "name": "csv.writer.writerow",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "os.getcwd": {
      "name": "os.getcwd",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Return a unicode string representing the current working directory."
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    },
    "statistics.mean": {
      "name": "statistics.mean",
      "type": "callable",
      "signature": "(data)",
      "short_docstring": "Return the sample arithmetic mean of data."
    }
  },
  "BigCodeBench/313": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "filename.split('.')": {
      "name": "filename.split('.')",
      "error": "Import error: No module named 'filename'"
    },
    "open.read()": {
      "name": "open.read()",
      "error": "Import error: No module named 'open'"
    },
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "re.search.group": {
      "name": "re.search.group",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Scan through string looking for a match to the pattern, returning\na Match object, or None if no match was found."
    },
    "re.search": {
      "name": "re.search",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Scan through string looking for a match to the pattern, returning\na Match object, or None if no match was found."
    },
    "shutil.move": {
      "name": "shutil.move",
      "type": "callable",
      "signature": "(src, dst)",
      "short_docstring": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command. Return the file or directory's\ndestination."
    }
  },
  "BigCodeBench/324": {
    "subprocess.Popen": {
      "name": "subprocess.Popen",
      "type": "class",
      "signature": "(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1, pipesize=-1)",
      "short_docstring": "Execute a child program in a new process.",
      "chains": {
        "poll": {
          "name": "subprocess.Popen.poll",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Check if child process has terminated. Set and return returncode\nattribute."
        }
      }
    },
    "exit_codes.append(process.poll())": {
      "name": "exit_codes.append(process.poll())",
      "error": "Import error: No module named 'exit_codes'"
    },
    "thread.join()": {
      "name": "thread.join()",
      "error": "Import error: No module named 'thread'"
    },
    "thread.start()": {
      "name": "thread.start()",
      "error": "Import error: No module named 'thread'"
    },
    "time.sleep": {
      "name": "time.sleep",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sleep(seconds)"
    }
  },
  "BigCodeBench/326": {
    "subprocess.Popen": {
      "name": "subprocess.Popen",
      "type": "class",
      "signature": "(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1, pipesize=-1)",
      "short_docstring": "Execute a child program in a new process.",
      "chains": {
        "wait": {
          "name": "subprocess.Popen.wait",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Wait for child process to terminate; returns self.returncode."
        }
      }
    },
    "glob.glob": {
      "name": "glob.glob",
      "type": "callable",
      "signature": "(pathname)",
      "short_docstring": "Return a list of paths matching a pathname pattern."
    },
    "os.path.basename": {
      "name": "os.path.basename",
      "type": "callable",
      "signature": "(p)",
      "short_docstring": "Returns the final component of a pathname"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "results.append((os.path.basename(file_path), None))": {
      "name": "results.append((os.path.basename(file_path), None))",
      "error": "Import error: No module named 'results'"
    },
    "results.append((os.path.basename(file_path), exit_code))": {
      "name": "results.append((os.path.basename(file_path), exit_code))",
      "error": "Import error: No module named 'results'"
    },
    "sys.stderr": {
      "name": "sys.stderr",
      "type": "constant",
      "signature": null,
      "short_docstring": "Character and line based layer over a BufferedIOBase object, buffer.",
      "value": "<_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>"
    }
  },
  "BigCodeBench/341": {
    "df.empty": {
      "name": "df.empty",
      "error": "Import error: No module named 'df'"
    },
    "df.columns": {
      "name": "df.columns",
      "error": "Import error: No module named 'df'"
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "(nrows=1, ncols=1, **fig_kw)",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "pandas.api.types.is_numeric_dtype": {
      "name": "pandas.api.types.is_numeric_dtype",
      "type": "callable",
      "signature": "(arr_or_dtype) -> 'bool)",
      "short_docstring": "Check whether the provided array or dtype is of a numeric dtype."
    },
    "seaborn.boxplot": {
      "name": "seaborn.boxplot",
      "type": "callable",
      "signature": "(x=None, ax=None, **kwargs)",
      "short_docstring": "Draw a box plot to show distributions with respect to categories."
    },
    "seaborn.countplot": {
      "name": "seaborn.countplot",
      "type": "callable",
      "signature": "(x=None, ax=None, **kwargs)",
      "short_docstring": "Show the counts of observations in each categorical bin using bars."
    },
    "seaborn.stripplot": {
      "name": "seaborn.stripplot",
      "type": "callable",
      "signature": "(x=None, jitter=True, ax=None, **kwargs)",
      "short_docstring": "Draw a categorical scatterplot using jitter to reduce overplotting."
    }
  },
  "BigCodeBench/346": {
    "subprocess.Popen": {
      "name": "subprocess.Popen",
      "type": "class",
      "signature": "(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1, pipesize=-1)",
      "short_docstring": "Execute a child program in a new process.",
      "chains": {
        "args": {
          "name": "subprocess.Popen.args",
          "type": "class",
          "signature": "(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1, pipesize=-1)",
          "short_docstring": "Execute a child program in a new process."
        },
        "poll": {
          "name": "subprocess.Popen.poll",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Check if child process has terminated. Set and return returncode\nattribute."
        },
        "returncode": {
          "name": "subprocess.Popen.returncode",
          "type": "class",
          "signature": "(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1, pipesize=-1)",
          "short_docstring": "Execute a child program in a new process."
        },
        "communicate": {
          "name": "subprocess.Popen.communicate",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Interact with process: Send data to stdin and close it.\nRead data from stdout and stderr, until end-of-file is\nreached.  Wait for process to terminate."
        }
      }
    },
    "os.path.isfile": {
      "name": "os.path.isfile",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path is a regular file"
    },
    "subprocess.PIPE": {
      "name": "subprocess.PIPE",
      "type": "constant",
      "signature": null,
      "short_docstring": "int([x]) -> integer\nint(x, base=10) -> integer",
      "value": "-1"
    },
    "sys.executable": {
      "name": "sys.executable",
      "type": "constant",
      "signature": null,
      "short_docstring": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str",
      "value": "/home/terryz1/do28/terryz1/apieval/miniconda/bin/python"
    },
    "time.sleep": {
      "name": "time.sleep",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sleep(seconds)"
    }
  },
  "BigCodeBench/360": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].bar": {
      "name": "matplotlib.pyplot.subplots[1].bar",
      "type": "method",
      "signature": "(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)",
      "short_docstring": "Make a bar plot."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "numpy.std": {
      "name": "numpy.std",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the standard deviation along the specified axis."
    },
    "numpy.mean": {
      "name": "numpy.mean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis."
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "pandas.read_excel.columns": {
      "name": "pandas.read_excel.columns",
      "type": "callable",
      "signature": "(io, sheet_name: 'str | int | list[IntStrT] | None' = 0, *, header: 'int | Sequence[int] | None' = 0, names: 'list[str] | None' = None, index_col: 'int | Sequence[int] | None' = None, usecols: 'int | str | Sequence[int] | Sequence[str] | Callable[[str], bool] | None' = None, dtype: 'DtypeArg | None' = None, engine: \"Literal['xlrd', 'openpyxl', 'odf', 'pyxlsb'] | None\" = None, converters: 'dict[str, Callable] | dict[int, Callable] | None' = None, true_values: 'Iterable[Hashable] | None' = None, false_values: 'Iterable[Hashable] | None' = None, skiprows: 'Sequence[int] | int | Callable[[int], object] | None' = None, nrows: 'int | None' = None, na_values=None, keep_default_na: 'bool' = True, na_filter: 'bool' = True, verbose: 'bool' = False, parse_dates: 'list | dict | bool' = False, date_parser: 'Callable | lib.NoDefault' = <no_default>, date_format: 'dict[Hashable, str] | str | None' = None, thousands: 'str | None' = None, decimal: 'str' = '.', comment: 'str | None' = None, skipfooter: 'int' = 0, storage_options: 'StorageOptions' = None, dtype_backend: 'DtypeBackend | lib.NoDefault' = <no_default>) -> 'DataFrame | dict[IntStrT, DataFrame]'",
      "short_docstring": "Read an Excel file into a pandas DataFrame."
    },
    "pandas.read_excel": {
      "name": "pandas.read_excel",
      "type": "callable",
      "signature": "(io, sheet_name: 'str | int | list[IntStrT] | None' = 0)",
      "short_docstring": "Read an Excel file into a pandas DataFrame."
    }
  },
  "BigCodeBench/367": {
    "activity.strftime('%A')": {
      "name": "activity.strftime('%A')",
      "error": "Import error: No module named 'activity'"
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].bar": {
      "name": "matplotlib.pyplot.subplots[1].bar",
      "type": "method",
      "signature": "(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)",
      "short_docstring": "Make a bar plot."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    }
  },
  "BigCodeBench/368": {
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "random.choice": {
      "name": "random.choice",
      "type": "callable",
      "signature": "(seq)",
      "short_docstring": "Choose a random element from a non-empty sequence."
    },
    "shutil.move": {
      "name": "shutil.move",
      "type": "callable",
      "signature": "(src, dst)",
      "short_docstring": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command. Return the file or directory's\ndestination."
    }
  },
  "BigCodeBench/374": {
    "cell.value": {
      "name": "cell.value",
      "error": "Import error: No module named 'cell'"
    },
    "glob.glob": {
      "name": "glob.glob",
      "type": "callable",
      "signature": "(pathname)",
      "short_docstring": "Return a list of paths matching a pathname pattern."
    },
    "openpyxl.load_workbook.sheetnames": {
      "name": "openpyxl.load_workbook.sheetnames",
      "type": "callable",
      "signature": "(filename, read_only=False, keep_vba=False, data_only=False, keep_links=True, rich_text=False)",
      "short_docstring": "Open the given filename and return the workbook"
    },
    "openpyxl.load_workbook.save": {
      "name": "openpyxl.load_workbook.save",
      "type": "callable",
      "signature": "(filename)",
      "short_docstring": "Open the given filename and return the workbook"
    },
    "openpyxl.load_workbook": {
      "name": "openpyxl.load_workbook",
      "type": "callable",
      "signature": "(filename)",
      "short_docstring": "Open the given filename and return the workbook"
    },
    "os.path.isdir": {
      "name": "os.path.isdir",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Return true if the pathname refers to an existing directory."
    },
    "regex.sub": {
      "name": "regex.sub",
      "type": "callable",
      "signature": "(pattern, repl, string)",
      "short_docstring": "Return the string obtained by replacing the leftmost (or rightmost with a\nreverse pattern) non-overlapping occurrences of the pattern in string by the\nreplacement repl. repl can be either a string or a callable; if a string,\nbackslash escapes in it are processed; if a callable, it's passed the match\nobject and must return a replacement string to be used."
    }
  },
  "BigCodeBench/399": {
    "math.pi": {
      "name": "math.pi",
      "type": "constant",
      "signature": null,
      "short_docstring": "Convert a string or number to a floating point number, if possible.",
      "value": "3.141592653589793"
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "numpy.sin": {
      "name": "numpy.sin",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "numpy.cos": {
      "name": "numpy.cos",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "numpy.linspace": {
      "name": "numpy.linspace",
      "type": "callable",
      "signature": "(start, stop, num=50)",
      "short_docstring": "Return evenly spaced numbers over a specified interval."
    }
  },
  "BigCodeBench/401": {
    "flask.Flask": {
      "name": "flask.Flask",
      "type": "class",
      "signature": "(import_name: 'str', static_url_path: 'str | None' = None, static_folder: 'str | os.PathLike[str] | None' = 'static', static_host: 'str | None' = None, host_matching: 'bool' = False, subdomain_matching: 'bool' = False, template_folder: 'str | os.PathLike[str] | None' = 'templates', instance_path: 'str | None' = None, instance_relative_config: 'bool' = False, root_path: 'str | None' = None)",
      "short_docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more.",
      "chains": {
        "config": {
          "name": "flask.Flask.config",
          "type": "class",
          "signature": "(import_name: 'str', static_url_path: 'str | None' = None, static_folder: 'str | os.PathLike[str] | None' = 'static', static_host: 'str | None' = None, host_matching: 'bool' = False, subdomain_matching: 'bool' = False, template_folder: 'str | os.PathLike[str] | None' = 'templates', instance_path: 'str | None' = None, instance_relative_config: 'bool' = False, root_path: 'str | None' = None)",
          "short_docstring": "The flask object implements a WSGI application and acts as the central\nobject.  It is passed the name of the module or package of the\napplication.  Once it is created it will act as a central registry for\nthe view functions, the URL rules, template configuration and much more."
        }
      }
    },
    "os.getenv": {
      "name": "os.getenv",
      "type": "callable",
      "signature": "(key, default=None)",
      "short_docstring": "Get an environment variable, return None if it doesn't exist.\nThe optional second argument can specify an alternate default.\nkey, default and the result are str."
    }
  },
  "BigCodeBench/409": {
    "numpy.std": {
      "name": "numpy.std",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the standard deviation along the specified axis."
    },
    "numpy.mean": {
      "name": "numpy.mean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis."
    },
    "numpy.median": {
      "name": "numpy.median",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the median along the specified axis."
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "pandas.read_excel.columns": {
      "name": "pandas.read_excel.columns",
      "type": "callable",
      "signature": "(io, sheet_name: 'str | int | list[IntStrT] | None' = 0, *, header: 'int | Sequence[int] | None' = 0, names: 'list[str] | None' = None, index_col: 'int | Sequence[int] | None' = None, usecols: 'int | str | Sequence[int] | Sequence[str] | Callable[[str], bool] | None' = None, dtype: 'DtypeArg | None' = None, engine: \"Literal['xlrd', 'openpyxl', 'odf', 'pyxlsb'] | None\" = None, converters: 'dict[str, Callable] | dict[int, Callable] | None' = None, true_values: 'Iterable[Hashable] | None' = None, false_values: 'Iterable[Hashable] | None' = None, skiprows: 'Sequence[int] | int | Callable[[int], object] | None' = None, nrows: 'int | None' = None, na_values=None, keep_default_na: 'bool' = True, na_filter: 'bool' = True, verbose: 'bool' = False, parse_dates: 'list | dict | bool' = False, date_parser: 'Callable | lib.NoDefault' = <no_default>, date_format: 'dict[Hashable, str] | str | None' = None, thousands: 'str | None' = None, decimal: 'str' = '.', comment: 'str | None' = None, skipfooter: 'int' = 0, storage_options: 'StorageOptions' = None, dtype_backend: 'DtypeBackend | lib.NoDefault' = <no_default>) -> 'DataFrame | dict[IntStrT, DataFrame]'",
      "short_docstring": "Read an Excel file into a pandas DataFrame."
    },
    "pandas.read_excel": {
      "name": "pandas.read_excel",
      "type": "callable",
      "signature": "(io)",
      "short_docstring": "Read an Excel file into a pandas DataFrame."
    }
  },
  "BigCodeBench/417": {
    "keras.optimizers.SGD": {
      "name": "keras.optimizers.SGD",
      "type": "class",
      "signature": "(learning_rate=0.01, **kwargs)",
      "short_docstring": "Gradient descent (with momentum) optimizer."
    },
    "keras.layers.Dense": {
      "name": "keras.layers.Dense",
      "type": "class",
      "signature": "(units, activation=None, **kwargs)",
      "short_docstring": "Just your regular densely-connected NN layer."
    },
    "keras.models.Sequential": {
      "name": "keras.models.Sequential",
      "type": "class",
      "signature": "(layers=None)",
      "short_docstring": "`Sequential` groups a linear stack of layers into a `tf.keras.Model`."
    },
    "keras.models.Sequential.compile": {
      "name": "keras.models.Sequential.compile",
      "type": "callable",
      "signature": "(self, optimizer='rmsprop', loss=None, **kwargs)",
      "short_docstring": "Configures the model for training."
    },
    "keras.models.Sequential.fit": {
      "name": "keras.models.Sequential.fit",
      "type": "callable",
      "signature": "(self, x=None, y=None, batch_size=None, epochs=1, verbose='auto', validation_data=None)",
      "short_docstring": "Trains the model for a fixed number of epochs (iterations on a dataset)."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "sklearn.model_selection.train_test_split": {
      "name": "sklearn.model_selection.train_test_split",
      "type": "callable",
      "signature": "(*arrays, test_size=None)",
      "short_docstring": "Split arrays or matrices into random train and test subsets."
    }
  },
  "BigCodeBench/418": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "sklearn.metrics.auc": {
      "name": "sklearn.metrics.auc",
      "type": "callable",
      "signature": "(x, y)",
      "short_docstring": "Compute Area Under the Curve (AUC) using the trapezoidal rule."
    },
    "sklearn.metrics.roc_curve": {
      "name": "sklearn.metrics.roc_curve",
      "type": "callable",
      "signature": "(y_true, y_score)",
      "short_docstring": "Compute Receiver operating characteristic (ROC)."
    },
    "sklearn.model_selection.train_test_split": {
      "name": "sklearn.model_selection.train_test_split",
      "type": "callable",
      "signature": "(*arrays, test_size=None)",
      "short_docstring": "Split arrays or matrices into random train and test subsets."
    },
    "tensorflow.keras.optimizers.SGD": {
      "name": "tensorflow.keras.optimizers.SGD",
      "type": "class",
      "signature": "(learning_rate=0.01, **kwargs)",
      "short_docstring": "Gradient descent (with momentum) optimizer."
    },
    "tensorflow.keras.Sequential.predict": {
      "name": "tensorflow.keras.Sequential.predict",
      "type": "callable",
      "signature": "(self, x, verbose='auto')",
      "short_docstring": "Generates output predictions for the input samples."
    },
    "tensorflow.keras.layers.Dense": {
      "name": "tensorflow.keras.layers.Dense",
      "type": "class",
      "signature": "(units, activation=None, **kwargs)",
      "short_docstring": "Just your regular densely-connected NN layer."
    },
    "tensorflow.keras.Sequential.fit": {
      "name": "tensorflow.keras.Sequential.fit",
      "type": "callable",
      "signature": "(self, x=None, y=None, batch_size=None, epochs=1, verbose='auto')",
      "short_docstring": "Trains the model for a fixed number of epochs (iterations on a dataset)."
    },
    "tensorflow.keras.Sequential": {
      "name": "tensorflow.keras.Sequential",
      "type": "class",
      "signature": "(layers=None)",
      "short_docstring": "`Sequential` groups a linear stack of layers into a `tf.keras.Model`."
    },
    "tensorflow.keras.Sequential.compile": {
      "name": "tensorflow.keras.Sequential.compile",
      "type": "callable",
      "signature": "(self, optimizer='rmsprop', loss=None, **kwargs)",
      "short_docstring": "Configures the model for training."
    }
  },
  "BigCodeBench/424": {
    "cv2.imread.shape": {
      "name": "cv2.imread.shape",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "imread(filename[, flags]) -> retval\n.   @brief Loads an image from a file.\n.   \n.   @anchor imread\n.   \n.   The function imread loads an image from the specified file and returns it. If the image cannot be\n.   read (because of missing file, improper permissions, unsupported or invalid format), the function\n.   returns an empty matrix ( Mat::data==NULL ).\n.   \n.   Currently, the following file formats are supported:\n.   \n.   -   Windows bitmaps - \\*.bmp, \\*.dib (always supported)\n.   -   JPEG files - \\*.jpeg, \\*.jpg, \\*.jpe (see the *Note* section)\n.   -   JPEG 2000 files - \\*.jp2 (see the *Note* section)\n.   -   Portable Network Graphics - \\*.png (see the *Note* section)\n.   -   WebP - \\*.webp (see the *Note* section)\n.   -   AVIF - \\*.avif (see the *Note* section)\n.   -   Portable image format - \\*.pbm, \\*.pgm, \\*.ppm \\*.pxm, \\*.pnm (always supported)\n.   -   PFM files - \\*.pfm (see the *Note* section)\n.   -   Sun rasters - \\*.sr, \\*.ras (always supported)\n.   -   TIFF files - \\*.tiff, \\*.tif (see the *Note* section)\n.   -   OpenEXR Image files - \\*.exr (see the *Note* section)\n.   -   Radiance HDR - \\*.hdr, \\*.pic (always supported)\n.   -   Raster and Vector geospatial data supported by GDAL (see the *Note* section)\n.   \n.   @note\n.   -   The function determines the type of an image by the content, not by the file extension.\n.   -   In the case of color images, the decoded images will have the channels stored in **B G R** order.\n.   -   When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available.\n.       Results may differ to the output of cvtColor()\n.   -   On Microsoft Windows\\* OS and MacOSX\\*, the codecs shipped with an OpenCV image (libjpeg,\n.       libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs,\n.       and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware\n.       that currently these native image loaders give images with different pixel values because of\n.       the color management embedded into MacOSX.\n.   -   On Linux\\*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for\n.       codecs supplied with an OS image. Install the relevant packages (do not forget the development\n.       files, for example, \"libjpeg-dev\", in Debian\\* and Ubuntu\\*) to get the codec support or turn\n.       on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n.   -   In the case you set *WITH_GDAL* flag to true in CMake and @ref IMREAD_LOAD_GDAL to load the image,\n.       then the [GDAL](http://www.gdal.org) driver will be used in order to decode the image, supporting\n.       the following formats: [Raster](http://www.gdal.org/formats_list.html),\n.       [Vector](http://www.gdal.org/ogr_formats.html).\n.   -   If EXIF information is embedded in the image file, the EXIF orientation will be taken into account\n.       and thus the image will be rotated accordingly except if the flags @ref IMREAD_IGNORE_ORIENTATION\n.       or @ref IMREAD_UNCHANGED are passed.\n.   -   Use the IMREAD_UNCHANGED flag to keep the floating point values from PFM image.\n.   -   By default number of pixels must be less than 2^30. Limit can be set using system\n.       variable OPENCV_IO_MAX_IMAGE_PIXELS\n.   \n.   @param filename Name of file to be loaded.\n.   @param flags Flag that can take values of cv::ImreadModes"
    },
    "cv2.imread.copy": {
      "name": "cv2.imread.copy",
      "type": "callable",
      "signature": "()",
      "short_docstring": "imread(filename[, flags]) -> retval\n.   @brief Loads an image from a file.\n.   \n.   @anchor imread\n.   \n.   The function imread loads an image from the specified file and returns it. If the image cannot be\n.   read (because of missing file, improper permissions, unsupported or invalid format), the function\n.   returns an empty matrix ( Mat::data==NULL ).\n.   \n.   Currently, the following file formats are supported:\n.   \n.   -   Windows bitmaps - \\*.bmp, \\*.dib (always supported)\n.   -   JPEG files - \\*.jpeg, \\*.jpg, \\*.jpe (see the *Note* section)\n.   -   JPEG 2000 files - \\*.jp2 (see the *Note* section)\n.   -   Portable Network Graphics - \\*.png (see the *Note* section)\n.   -   WebP - \\*.webp (see the *Note* section)\n.   -   AVIF - \\*.avif (see the *Note* section)\n.   -   Portable image format - \\*.pbm, \\*.pgm, \\*.ppm \\*.pxm, \\*.pnm (always supported)\n.   -   PFM files - \\*.pfm (see the *Note* section)\n.   -   Sun rasters - \\*.sr, \\*.ras (always supported)\n.   -   TIFF files - \\*.tiff, \\*.tif (see the *Note* section)\n.   -   OpenEXR Image files - \\*.exr (see the *Note* section)\n.   -   Radiance HDR - \\*.hdr, \\*.pic (always supported)\n.   -   Raster and Vector geospatial data supported by GDAL (see the *Note* section)\n.   \n.   @note\n.   -   The function determines the type of an image by the content, not by the file extension.\n.   -   In the case of color images, the decoded images will have the channels stored in **B G R** order.\n.   -   When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available.\n.       Results may differ to the output of cvtColor()\n.   -   On Microsoft Windows\\* OS and MacOSX\\*, the codecs shipped with an OpenCV image (libjpeg,\n.       libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs,\n.       and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware\n.       that currently these native image loaders give images with different pixel values because of\n.       the color management embedded into MacOSX.\n.   -   On Linux\\*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for\n.       codecs supplied with an OS image. Install the relevant packages (do not forget the development\n.       files, for example, \"libjpeg-dev\", in Debian\\* and Ubuntu\\*) to get the codec support or turn\n.       on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n.   -   In the case you set *WITH_GDAL* flag to true in CMake and @ref IMREAD_LOAD_GDAL to load the image,\n.       then the [GDAL](http://www.gdal.org) driver will be used in order to decode the image, supporting\n.       the following formats: [Raster](http://www.gdal.org/formats_list.html),\n.       [Vector](http://www.gdal.org/ogr_formats.html).\n.   -   If EXIF information is embedded in the image file, the EXIF orientation will be taken into account\n.       and thus the image will be rotated accordingly except if the flags @ref IMREAD_IGNORE_ORIENTATION\n.       or @ref IMREAD_UNCHANGED are passed.\n.   -   Use the IMREAD_UNCHANGED flag to keep the floating point values from PFM image.\n.   -   By default number of pixels must be less than 2^30. Limit can be set using system\n.       variable OPENCV_IO_MAX_IMAGE_PIXELS\n.   \n.   @param filename Name of file to be loaded.\n.   @param flags Flag that can take values of cv::ImreadModes"
    },
    "cv2.imread": {
      "name": "cv2.imread",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "imread(filename[, flags]) -> retval\n.   @brief Loads an image from a file.\n.   \n.   @anchor imread\n.   \n.   The function imread loads an image from the specified file and returns it. If the image cannot be\n.   read (because of missing file, improper permissions, unsupported or invalid format), the function\n.   returns an empty matrix ( Mat::data==NULL ).\n.   \n.   Currently, the following file formats are supported:\n.   \n.   -   Windows bitmaps - \\*.bmp, \\*.dib (always supported)\n.   -   JPEG files - \\*.jpeg, \\*.jpg, \\*.jpe (see the *Note* section)\n.   -   JPEG 2000 files - \\*.jp2 (see the *Note* section)\n.   -   Portable Network Graphics - \\*.png (see the *Note* section)\n.   -   WebP - \\*.webp (see the *Note* section)\n.   -   AVIF - \\*.avif (see the *Note* section)\n.   -   Portable image format - \\*.pbm, \\*.pgm, \\*.ppm \\*.pxm, \\*.pnm (always supported)\n.   -   PFM files - \\*.pfm (see the *Note* section)\n.   -   Sun rasters - \\*.sr, \\*.ras (always supported)\n.   -   TIFF files - \\*.tiff, \\*.tif (see the *Note* section)\n.   -   OpenEXR Image files - \\*.exr (see the *Note* section)\n.   -   Radiance HDR - \\*.hdr, \\*.pic (always supported)\n.   -   Raster and Vector geospatial data supported by GDAL (see the *Note* section)\n.   \n.   @note\n.   -   The function determines the type of an image by the content, not by the file extension.\n.   -   In the case of color images, the decoded images will have the channels stored in **B G R** order.\n.   -   When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available.\n.       Results may differ to the output of cvtColor()\n.   -   On Microsoft Windows\\* OS and MacOSX\\*, the codecs shipped with an OpenCV image (libjpeg,\n.       libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs,\n.       and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware\n.       that currently these native image loaders give images with different pixel values because of\n.       the color management embedded into MacOSX.\n.   -   On Linux\\*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for\n.       codecs supplied with an OS image. Install the relevant packages (do not forget the development\n.       files, for example, \"libjpeg-dev\", in Debian\\* and Ubuntu\\*) to get the codec support or turn\n.       on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n.   -   In the case you set *WITH_GDAL* flag to true in CMake and @ref IMREAD_LOAD_GDAL to load the image,\n.       then the [GDAL](http://www.gdal.org) driver will be used in order to decode the image, supporting\n.       the following formats: [Raster](http://www.gdal.org/formats_list.html),\n.       [Vector](http://www.gdal.org/ogr_formats.html).\n.   -   If EXIF information is embedded in the image file, the EXIF orientation will be taken into account\n.       and thus the image will be rotated accordingly except if the flags @ref IMREAD_IGNORE_ORIENTATION\n.       or @ref IMREAD_UNCHANGED are passed.\n.   -   Use the IMREAD_UNCHANGED flag to keep the floating point values from PFM image.\n.   -   By default number of pixels must be less than 2^30. Limit can be set using system\n.       variable OPENCV_IO_MAX_IMAGE_PIXELS\n.   \n.   @param filename Name of file to be loaded.\n.   @param flags Flag that can take values of cv::ImreadModes"
    },
    "cv2.imread.reshape": {
      "name": "cv2.imread.reshape",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "imread(filename[, flags]) -> retval\n.   @brief Loads an image from a file.\n.   \n.   @anchor imread\n.   \n.   The function imread loads an image from the specified file and returns it. If the image cannot be\n.   read (because of missing file, improper permissions, unsupported or invalid format), the function\n.   returns an empty matrix ( Mat::data==NULL ).\n.   \n.   Currently, the following file formats are supported:\n.   \n.   -   Windows bitmaps - \\*.bmp, \\*.dib (always supported)\n.   -   JPEG files - \\*.jpeg, \\*.jpg, \\*.jpe (see the *Note* section)\n.   -   JPEG 2000 files - \\*.jp2 (see the *Note* section)\n.   -   Portable Network Graphics - \\*.png (see the *Note* section)\n.   -   WebP - \\*.webp (see the *Note* section)\n.   -   AVIF - \\*.avif (see the *Note* section)\n.   -   Portable image format - \\*.pbm, \\*.pgm, \\*.ppm \\*.pxm, \\*.pnm (always supported)\n.   -   PFM files - \\*.pfm (see the *Note* section)\n.   -   Sun rasters - \\*.sr, \\*.ras (always supported)\n.   -   TIFF files - \\*.tiff, \\*.tif (see the *Note* section)\n.   -   OpenEXR Image files - \\*.exr (see the *Note* section)\n.   -   Radiance HDR - \\*.hdr, \\*.pic (always supported)\n.   -   Raster and Vector geospatial data supported by GDAL (see the *Note* section)\n.   \n.   @note\n.   -   The function determines the type of an image by the content, not by the file extension.\n.   -   In the case of color images, the decoded images will have the channels stored in **B G R** order.\n.   -   When using IMREAD_GRAYSCALE, the codec's internal grayscale conversion will be used, if available.\n.       Results may differ to the output of cvtColor()\n.   -   On Microsoft Windows\\* OS and MacOSX\\*, the codecs shipped with an OpenCV image (libjpeg,\n.       libpng, libtiff, and libjasper) are used by default. So, OpenCV can always read JPEGs, PNGs,\n.       and TIFFs. On MacOSX, there is also an option to use native MacOSX image readers. But beware\n.       that currently these native image loaders give images with different pixel values because of\n.       the color management embedded into MacOSX.\n.   -   On Linux\\*, BSD flavors and other Unix-like open-source operating systems, OpenCV looks for\n.       codecs supplied with an OS image. Install the relevant packages (do not forget the development\n.       files, for example, \"libjpeg-dev\", in Debian\\* and Ubuntu\\*) to get the codec support or turn\n.       on the OPENCV_BUILD_3RDPARTY_LIBS flag in CMake.\n.   -   In the case you set *WITH_GDAL* flag to true in CMake and @ref IMREAD_LOAD_GDAL to load the image,\n.       then the [GDAL](http://www.gdal.org) driver will be used in order to decode the image, supporting\n.       the following formats: [Raster](http://www.gdal.org/formats_list.html),\n.       [Vector](http://www.gdal.org/ogr_formats.html).\n.   -   If EXIF information is embedded in the image file, the EXIF orientation will be taken into account\n.       and thus the image will be rotated accordingly except if the flags @ref IMREAD_IGNORE_ORIENTATION\n.       or @ref IMREAD_UNCHANGED are passed.\n.   -   Use the IMREAD_UNCHANGED flag to keep the floating point values from PFM image.\n.   -   By default number of pixels must be less than 2^30. Limit can be set using system\n.       variable OPENCV_IO_MAX_IMAGE_PIXELS\n.   \n.   @param filename Name of file to be loaded.\n.   @param flags Flag that can take values of cv::ImreadModes"
    },
    "cv2.imwrite": {
      "name": "cv2.imwrite",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "imwrite(filename, img[, params]) -> retval\n.   @brief Saves an image to a specified file.\n.   \n.   The function imwrite saves the image to the specified file. The image format is chosen based on the\n.   filename extension (see cv::imread for the list of extensions). In general, only 8-bit unsigned (CV_8U)\n.   single-channel or 3-channel (with 'BGR' channel order) images\n.   can be saved using this function, with these exceptions:\n.   \n.   - With OpenEXR encoder, only 32-bit float (CV_32F) images can be saved.\n.     - 8-bit unsigned (CV_8U) images are not supported.\n.   - With Radiance HDR encoder, non 64-bit float (CV_64F) images can be saved.\n.     - All images will be converted to 32-bit float (CV_32F).\n.   - With JPEG 2000 encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n.   - With PAM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n.   - With PNG encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n.     - PNG images with an alpha channel can be saved using this function. To do this, create\n.       8-bit (or 16-bit) 4-channel image BGRA, where the alpha channel goes last. Fully transparent pixels\n.       should have alpha set to 0, fully opaque pixels should have alpha set to 255/65535 (see the code sample below).\n.   - With PGM/PPM encoder, 8-bit unsigned (CV_8U) and 16-bit unsigned (CV_16U) images can be saved.\n.   - With TIFF encoder, 8-bit unsigned (CV_8U), 16-bit unsigned (CV_16U),\n.                        32-bit float (CV_32F) and 64-bit float (CV_64F) images can be saved.\n.     - Multiple images (vector of Mat) can be saved in TIFF format (see the code sample below).\n.     - 32-bit float 3-channel (CV_32FC3) TIFF images will be saved\n.       using the LogLuv high dynamic range encoding (4 bytes per pixel)\n.   \n.   If the image format is not supported, the image will be converted to 8-bit unsigned (CV_8U) and saved that way.\n.   \n.   If the format, depth or channel order is different, use\n.   Mat::convertTo and cv::cvtColor to convert it before saving. Or, use the universal FileStorage I/O\n.   functions to save the image to XML or YAML format.\n.   \n.   The sample below shows how to create a BGRA image, how to set custom compression parameters and save it to a PNG file.\n.   It also demonstrates how to save multiple images in a TIFF file:\n.   @include snippets/imgcodecs_imwrite.cpp\n.   @param filename Name of the file.\n.   @param img (Mat or vector of Mat) Image or Images to be saved.\n.   @param params Format-specific parameters encoded as pairs (paramId_1, paramValue_1, paramId_2, paramValue_2, ... .) see cv::ImwriteFlags"
    },
    "numpy.array": {
      "name": "numpy.array",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    },
    "numpy.stack": {
      "name": "numpy.stack",
      "type": "callable",
      "signature": "(arrays, axis=0)",
      "short_docstring": "Join a sequence of arrays along a new axis."
    },
    "numpy.where": {
      "name": "numpy.where",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "where(condition, [x, y])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "segmented_image.reshape(img.shape).astype.reshape(img.shape)": {
      "name": "segmented_image.reshape(img.shape).astype.reshape(img.shape)",
      "error": "Import error: No module named 'astype'"
    },
    "sklearn.cluster.KMeans.labels_": {
      "name": "sklearn.cluster.KMeans.labels_",
      "type": "class",
      "signature": "(n_clusters=8, *, init='k-means++', n_init='warn', max_iter=300, tol=0.0001, verbose=0, random_state=None, copy_x=True, algorithm='lloyd')",
      "short_docstring": "K-Means clustering."
    },
    "sklearn.cluster.KMeans.fit": {
      "name": "sklearn.cluster.KMeans.fit",
      "type": "callable",
      "signature": "(self, X)",
      "short_docstring": "Compute k-means clustering."
    },
    "sklearn.cluster.KMeans.cluster_centers_": {
      "name": "sklearn.cluster.KMeans.cluster_centers_",
      "type": "class",
      "signature": "(n_clusters=8, *, init='k-means++', n_init='warn', max_iter=300, tol=0.0001, verbose=0, random_state=None, copy_x=True, algorithm='lloyd')",
      "short_docstring": "K-Means clustering."
    },
    "sklearn.cluster.KMeans.labels_.reshape": {
      "name": "sklearn.cluster.KMeans.labels_.reshape",
      "type": "class",
      "signature": "(n_clusters=8)",
      "short_docstring": "K-Means clustering."
    },
    "sklearn.cluster.KMeans": {
      "name": "sklearn.cluster.KMeans",
      "type": "class",
      "signature": "(n_clusters=8, random_state=None)",
      "short_docstring": "K-Means clustering."
    }
  },
  "BigCodeBench/443": {
    "T.shape": {
      "name": "T.shape",
      "error": "Import error: No module named 'T'"
    },
    "matplotlib.pyplot.Axes": {
      "name": "matplotlib.pyplot.Axes",
      "type": "class",
      "signature": "(fig, *args, facecolor=None, frameon=True, sharex=None, sharey=None, label='', xscale=None, yscale=None, box_aspect=None, **kwargs)",
      "short_docstring": "An Axes object encapsulates all the elements of an individual (sub-)plot in\na figure."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].scatter": {
      "name": "matplotlib.pyplot.subplots[1].scatter",
      "type": "method",
      "signature": "(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)",
      "short_docstring": "A scatter plot of *y* vs. *x* with varying marker size and/or color."
    },
    "numpy.tensordot": {
      "name": "numpy.tensordot",
      "type": "callable",
      "signature": "(a, b, axes=2)",
      "short_docstring": "Compute tensor dot product along specified axes."
    },
    "numpy.tensordot.swapaxes.reshape": {
      "name": "numpy.tensordot.swapaxes.reshape",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Compute tensor dot product along specified axes."
    },
    "sklearn.cluster.KMeans.fit_predict": {
      "name": "sklearn.cluster.KMeans.fit_predict",
      "type": "callable",
      "signature": "(self, X)",
      "short_docstring": "Compute cluster centers and predict cluster index for each sample."
    },
    "sklearn.cluster.KMeans": {
      "name": "sklearn.cluster.KMeans",
      "type": "class",
      "signature": "(n_clusters=8, n_init='warn', random_state=None)",
      "short_docstring": "K-Means clustering."
    }
  },
  "BigCodeBench/445": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "numpy.random.normal": {
      "name": "numpy.random.normal",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "normal(loc=0.0, scale=1.0, size=None)"
    },
    "points.shape": {
      "name": "points.shape",
      "error": "Import error: No module named 'points'"
    },
    "scipy.spatial.Voronoi": {
      "name": "scipy.spatial.Voronoi",
      "type": "class",
      "signature": "(points)",
      "short_docstring": "Voronoi(points, furthest_site=False, incremental=False, qhull_options=None)"
    },
    "scipy.spatial.voronoi_plot_2d": {
      "name": "scipy.spatial.voronoi_plot_2d",
      "type": "callable",
      "signature": "(vor, ax=None, **kw)",
      "short_docstring": "Plot the given Voronoi diagram in 2-D"
    }
  },
  "BigCodeBench/454": {
    "files_moved.append(dest_file_path)": {
      "name": "files_moved.append(dest_file_path)",
      "error": "Import error: No module named 'files_moved'"
    },
    "glob.glob": {
      "name": "glob.glob",
      "type": "callable",
      "signature": "(pathname)",
      "short_docstring": "Return a list of paths matching a pathname pattern."
    },
    "os.path.basename": {
      "name": "os.path.basename",
      "type": "callable",
      "signature": "(p)",
      "short_docstring": "Returns the final component of a pathname"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "shutil.move": {
      "name": "shutil.move",
      "type": "callable",
      "signature": "(src, dst)",
      "short_docstring": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command. Return the file or directory's\ndestination."
    }
  },
  "BigCodeBench/458": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "columns": {
          "name": "pandas.DataFrame.columns",
          "type": "constant",
          "signature": null,
          "short_docstring": "The column labels of the DataFrame.",
          "value": "<pandas._libs.properties.AxisProperty object at 0x7f3e47317f40>"
        }
      }
    },
    "json.loads.items": {
      "name": "json.loads.items",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object."
    },
    "json.loads.values": {
      "name": "json.loads.values",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object."
    },
    "json.loads": {
      "name": "json.loads",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object."
    },
    "pandas.to_numeric.isnull": {
      "name": "pandas.to_numeric.isnull",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Convert argument to a numeric type."
    },
    "pandas.to_numeric": {
      "name": "pandas.to_numeric",
      "type": "callable",
      "signature": "(arg, errors: 'DateTimeErrorChoices' = 'raise')",
      "short_docstring": "Convert argument to a numeric type."
    },
    "re.compile.match": {
      "name": "re.compile.match",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    },
    "re.compile": {
      "name": "re.compile",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    }
  },
  "BigCodeBench/461": {
    "psutil.Process": {
      "name": "psutil.Process",
      "type": "class",
      "signature": "(pid=None)",
      "short_docstring": "Represents an OS process with the given PID.\nIf PID is omitted current process PID (os.getpid()) is used.\nRaise NoSuchProcess if PID does not exist.",
      "chains": {
        "is_running": {
          "name": "psutil.Process.is_running",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Return whether this process is running.\nIt also checks if PID has been reused by another process in\nwhich case return False."
        },
        "memory_info": {
          "name": "psutil.Process.memory_info",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Return a namedtuple with variable fields depending on the\nplatform, representing memory information about the process."
        },
        "cpu_percent": {
          "name": "psutil.Process.cpu_percent",
          "type": "callable",
          "signature": "(self, interval=None)",
          "short_docstring": "Return a float representing the current process CPU\nutilization as a percentage."
        }
      }
    },
    "subprocess.Popen": {
      "name": "subprocess.Popen",
      "type": "class",
      "signature": "(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1, pipesize=-1)",
      "short_docstring": "Execute a child program in a new process.",
      "chains": {
        "pid": {
          "name": "subprocess.Popen.pid",
          "type": "class",
          "signature": "(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=None, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, user=None, group=None, extra_groups=None, encoding=None, errors=None, text=None, umask=-1, pipesize=-1)",
          "short_docstring": "Execute a child program in a new process."
        },
        "poll": {
          "name": "subprocess.Popen.poll",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Check if child process has terminated. Set and return returncode\nattribute."
        },
        "wait": {
          "name": "subprocess.Popen.wait",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Wait for child process to terminate; returns self.returncode."
        },
        "terminate": {
          "name": "subprocess.Popen.terminate",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Terminate the process with SIGTERM\n            "
        }
      }
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "time.time": {
      "name": "time.time",
      "type": "callable",
      "signature": "()",
      "short_docstring": "time() -> floating point number"
    },
    "time.sleep": {
      "name": "time.sleep",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sleep(seconds)"
    }
  },
  "BigCodeBench/477": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].scatter": {
      "name": "matplotlib.pyplot.subplots[1].scatter",
      "type": "method",
      "signature": "(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)",
      "short_docstring": "A scatter plot of *y* vs. *x* with varying marker size and/or color."
    },
    "numpy.random.rand": {
      "name": "numpy.random.rand",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "rand(d0, d1, ..., dn)"
    },
    "numpy.array": {
      "name": "numpy.array",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "numpy.random.shuffle": {
      "name": "numpy.random.shuffle",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "shuffle(x)"
    },
    "numpy.random.choice": {
      "name": "numpy.random.choice",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "choice(a, size=None, replace=True, p=None)"
    },
    "numpy.concatenate": {
      "name": "numpy.concatenate",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "concatenate((a1, a2, ...), axis=0, out=None, dtype=None, casting=\"same_kind\")"
    }
  },
  "BigCodeBench/486": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "fromtimestamp": {
          "name": "datetime.datetime.fromtimestamp",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "timestamp[, tz] -> tz's local time from POSIX timestamp."
        }
      }
    },
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "loc": {
          "name": "pandas.DataFrame.loc",
          "type": "constant",
          "signature": null,
          "short_docstring": "Access a group of rows and columns by label(s) or a boolean array.",
          "value": "<property object at 0x7f3e4789d620>"
        },
        "plot": {
          "name": "pandas.DataFrame.plot",
          "type": "class",
          "signature": "()",
          "short_docstring": "Make plots of Series or DataFrame."
        }
      }
    },
    "df.plot.set_ylabel('Value')": {
      "name": "df.plot.set_ylabel('Value')",
      "error": "Import error: No module named 'df'"
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "numpy.arange": {
      "name": "numpy.arange",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "arange([start,] stop[, step,], dtype=None, *, like=None)"
    },
    "numpy.random.normal": {
      "name": "numpy.random.normal",
      "type": "callable",
      "signature": "(**kwargs)",
      "short_docstring": "normal(loc=0.0, scale=1.0, size=None)"
    }
  },
  "BigCodeBench/492": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        },
        "fromtimestamp": {
          "name": "datetime.datetime.fromtimestamp",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "timestamp[, tz] -> tz's local time from POSIX timestamp."
        }
      }
    },
    "pandas.date_range": {
      "name": "pandas.date_range",
      "type": "callable",
      "signature": "(start=None, end=None, freq=None, **kwargs) -> 'DatetimeIndex)",
      "short_docstring": "Return a fixed frequency DatetimeIndex."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    },
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "sales_data.append([product, date, sales])": {
      "name": "sales_data.append([product, date, sales])",
      "error": "Import error: No module named 'sales_data'"
    }
  },
  "BigCodeBench/501": {
    "book.add_sheet.write(0, col_index, col)": {
      "name": "book.add_sheet.write(0, col_index, col)",
      "error": "Import error: No module named 'book'"
    },
    "book.add_sheet.write(row_index + 1, col_index, row[col])": {
      "name": "book.add_sheet.write(row_index + 1, col_index, row[col])",
      "error": "Import error: No module named 'book'"
    },
    "os.path.abspath": {
      "name": "os.path.abspath",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Return an absolute path."
    },
    "pandas.read_json.empty": {
      "name": "pandas.read_json.empty",
      "type": "callable",
      "signature": "(path_or_buf: 'FilePath | ReadBuffer[str] | ReadBuffer[bytes]', *, orient: 'str | None' = None, typ: \"Literal['frame', 'series']\" = 'frame', dtype: 'DtypeArg | None' = None, convert_axes=None, convert_dates: 'bool | list[str]' = True, keep_default_dates: 'bool' = True, precise_float: 'bool' = False, date_unit: 'str | None' = None, encoding: 'str | None' = None, encoding_errors: 'str | None' = 'strict', lines: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', nrows: 'int | None' = None, storage_options: 'StorageOptions' = None, dtype_backend: 'DtypeBackend | lib.NoDefault' = <no_default>, engine: 'JSONEngine' = 'ujson') -> 'DataFrame | Series | JsonReader'",
      "short_docstring": "Convert a JSON string to pandas object."
    },
    "pandas.read_json.columns": {
      "name": "pandas.read_json.columns",
      "type": "callable",
      "signature": "(path_or_buf: 'FilePath | ReadBuffer[str] | ReadBuffer[bytes]', *, orient: 'str | None' = None, typ: \"Literal['frame', 'series']\" = 'frame', dtype: 'DtypeArg | None' = None, convert_axes=None, convert_dates: 'bool | list[str]' = True, keep_default_dates: 'bool' = True, precise_float: 'bool' = False, date_unit: 'str | None' = None, encoding: 'str | None' = None, encoding_errors: 'str | None' = 'strict', lines: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', nrows: 'int | None' = None, storage_options: 'StorageOptions' = None, dtype_backend: 'DtypeBackend | lib.NoDefault' = <no_default>, engine: 'JSONEngine' = 'ujson') -> 'DataFrame | Series | JsonReader'",
      "short_docstring": "Convert a JSON string to pandas object."
    },
    "pandas.read_json": {
      "name": "pandas.read_json",
      "type": "callable",
      "signature": "(path_or_buf: 'FilePath | ReadBuffer[str] | ReadBuffer[bytes]')",
      "short_docstring": "Convert a JSON string to pandas object."
    },
    "pandas.read_json.iterrows": {
      "name": "pandas.read_json.iterrows",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Convert a JSON string to pandas object."
    }
  },
  "BigCodeBench/502": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "data.append([date, activity, duration])": {
      "name": "data.append([date, activity, duration])",
      "error": "Import error: No module named 'data'"
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    },
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "seaborn.lineplot": {
      "name": "seaborn.lineplot",
      "type": "callable",
      "signature": "(data=None, x=None, y=None, hue=None, **kwargs)",
      "short_docstring": "Draw a line plot with possibility of several semantic groupings."
    }
  },
  "BigCodeBench/503": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "numpy.random.rand": {
      "name": "numpy.random.rand",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "rand(d0, d1, ..., dn)"
    },
    "pandas.date_range": {
      "name": "pandas.date_range",
      "type": "callable",
      "signature": "(end=None, periods=None, **kwargs) -> 'DatetimeIndex)",
      "short_docstring": "Return a fixed frequency DatetimeIndex."
    }
  },
  "BigCodeBench/509": {
    "csv.reader": {
      "name": "csv.reader",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_reader = reader(iterable [, dialect='excel']\n                        [optional keyword args])\n    for row in csv_reader:\n        process(row)"
    },
    "data.append([i + 1, status, content])": {
      "name": "data.append([i + 1, status, content])",
      "error": "Import error: No module named 'data'"
    },
    "difflib.ndiff": {
      "name": "difflib.ndiff",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Compare `a` and `b` (lists of strings); return a `Differ`-style delta."
    }
  },
  "BigCodeBench/511": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "empty": {
          "name": "pandas.DataFrame.empty",
          "type": "constant",
          "signature": null,
          "short_docstring": "Indicator whether Series/DataFrame is empty.",
          "value": "<property object at 0x7f3e4732bba0>"
        }
      }
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].pie": {
      "name": "matplotlib.pyplot.subplots[1].pie",
      "type": "method",
      "signature": "(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=0, radius=1, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, rotatelabels=False, *, normalize=True, hatch=None, data=None)",
      "short_docstring": "Plot a pie chart."
    },
    "numpy.nan": {
      "name": "numpy.nan",
      "type": "constant",
      "signature": null,
      "short_docstring": "Convert a string or number to a floating point number, if possible.",
      "value": "nan"
    },
    "numpy.min": {
      "name": "numpy.min",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Return the minimum of an array or minimum along an axis."
    },
    "numpy.sum": {
      "name": "numpy.sum",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Sum of array elements over a given axis."
    },
    "numpy.max": {
      "name": "numpy.max",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Return the maximum of an array or maximum along an axis."
    },
    "numpy.mean": {
      "name": "numpy.mean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis."
    }
  },
  "BigCodeBench/513": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "plot": {
          "name": "pandas.DataFrame.plot",
          "type": "class",
          "signature": "(data) -> 'None'",
          "short_docstring": "Make plots of Series or DataFrame."
        }
      }
    },
    "pandas.DataFrame.plot": {
      "name": "pandas.DataFrame.plot",
      "type": "class",
      "signature": "(data) -> 'None'",
      "short_docstring": "Make plots of Series or DataFrame.",
      "chains": {
        "line": {
          "name": "pandas.DataFrame.plot.line",
          "type": "callable",
          "signature": "(self, x=None, y=None, **kwargs) -> 'PlotAccessor)",
          "short_docstring": "Plot Series or DataFrame as lines."
        }
      }
    },
    "df.plot.line.set_ylabel(column)": {
      "name": "df.plot.line.set_ylabel(column)",
      "error": "Import error: No module named 'df'"
    },
    "matplotlib.pyplot.title": {
      "name": "matplotlib.pyplot.title",
      "type": "callable",
      "signature": "(label)",
      "short_docstring": "Set a title for the Axes."
    },
    "numpy.min": {
      "name": "numpy.min",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Return the minimum of an array or minimum along an axis."
    },
    "numpy.sum": {
      "name": "numpy.sum",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Sum of array elements over a given axis."
    },
    "numpy.max": {
      "name": "numpy.max",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Return the maximum of an array or maximum along an axis."
    },
    "numpy.mean": {
      "name": "numpy.mean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis."
    }
  },
  "BigCodeBench/526": {
    "collections.defaultdict": {
      "name": "collections.defaultdict",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "defaultdict(default_factory=None, /, [...]) --> dict with default factory",
      "chains": {
        "items": {
          "name": "collections.defaultdict.items",
          "type": "callable",
          "signature": "()",
          "short_docstring": "D.items() -> a set-like object providing a view on D's items"
        }
      }
    },
    "d.keys()": {
      "name": "d.keys()",
      "error": "Import error: No module named 'd'"
    },
    "d.get(key, np.nan)": {
      "name": "d.get(key, np.nan)",
      "error": "Import error: No module named 'd'"
    },
    "json.load": {
      "name": "json.load",
      "type": "callable",
      "signature": "(fp)",
      "short_docstring": "Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\na JSON document) to a Python object."
    },
    "numpy.nan": {
      "name": "numpy.nan",
      "type": "constant",
      "signature": null,
      "short_docstring": "Convert a string or number to a floating point number, if possible.",
      "value": "nan"
    },
    "numpy.nanmean": {
      "name": "numpy.nanmean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis, ignoring NaNs."
    },
    "numpy.nanmedian": {
      "name": "numpy.nanmedian",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the median along the specified axis, while ignoring NaNs."
    }
  },
  "BigCodeBench/528": {
    "collections.Counter": {
      "name": "collections.Counter",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "short_docstring": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.",
      "chains": {
        "keys": {
          "name": "collections.Counter.keys",
          "type": "callable",
          "signature": "()",
          "short_docstring": "D.keys() -> a set-like object providing a view on D's keys"
        },
        "values": {
          "name": "collections.Counter.values",
          "type": "callable",
          "signature": "()",
          "short_docstring": "D.values() -> an object providing a view on D's values"
        }
      }
    },
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "plot": {
          "name": "pandas.DataFrame.plot",
          "type": "class",
          "signature": "()",
          "short_docstring": "Make plots of Series or DataFrame."
        }
      }
    },
    "csv.reader": {
      "name": "csv.reader",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_reader = reader(iterable [, dialect='excel']\n                        [optional keyword args])\n    for row in csv_reader:\n        process(row)"
    },
    "df.plot.set_ylabel('Count')": {
      "name": "df.plot.set_ylabel('Count')",
      "error": "Import error: No module named 'df'"
    },
    "file_path.strip.lower()": {
      "name": "file_path.strip.lower()",
      "error": "Import error: No module named 'file_path'"
    },
    "file_path.strip.strip()": {
      "name": "file_path.strip.strip()",
      "error": "Import error: No module named 'file_path'"
    },
    "list.count(row)": {
      "name": "list.count(row)",
      "error": "Import error: No module named 'list'"
    },
    "matplotlib.pyplot.tight_layout": {
      "name": "matplotlib.pyplot.tight_layout",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Adjust the padding between and around subplots."
    }
  },
  "BigCodeBench/530": {
    "df.empty": {
      "name": "df.empty",
      "error": "Import error: No module named 'df'"
    },
    "matplotlib.pyplot.Axes": {
      "name": "matplotlib.pyplot.Axes",
      "type": "class",
      "signature": "(fig, *args, facecolor=None, frameon=True, sharex=None, sharey=None, label='', xscale=None, yscale=None, box_aspect=None, **kwargs)",
      "short_docstring": "An Axes object encapsulates all the elements of an individual (sub-)plot in\na figure."
    },
    "matplotlib.pyplot.xlabel": {
      "name": "matplotlib.pyplot.xlabel",
      "type": "callable",
      "signature": "(xlabel)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.ylabel": {
      "name": "matplotlib.pyplot.ylabel",
      "type": "callable",
      "signature": "(ylabel)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.title": {
      "name": "matplotlib.pyplot.title",
      "type": "callable",
      "signature": "(label)",
      "short_docstring": "Set a title for the Axes."
    },
    "numpy.floor": {
      "name": "numpy.floor",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "numpy.arange": {
      "name": "numpy.arange",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "arange([start,] stop[, step,], dtype=None, *, like=None)"
    },
    "seaborn.histplot": {
      "name": "seaborn.histplot",
      "type": "callable",
      "signature": "(data=None, bins='auto', **kwargs)",
      "short_docstring": "Plot univariate or bivariate histograms to show distributions of datasets."
    }
  },
  "BigCodeBench/532": {
    "df.empty": {
      "name": "df.empty",
      "error": "Import error: No module named 'df'"
    },
    "matplotlib.pyplot.xlim": {
      "name": "matplotlib.pyplot.xlim",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get or set the x limits of the current axes."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "matplotlib.pyplot.subplots[1].hist": {
      "name": "matplotlib.pyplot.subplots[1].hist",
      "type": "method",
      "signature": "(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)",
      "short_docstring": "Compute and plot a histogram."
    },
    "numpy.linspace": {
      "name": "numpy.linspace",
      "type": "callable",
      "signature": "(start, stop, num=50)",
      "short_docstring": "Return evenly spaced numbers over a specified interval."
    },
    "scipy.stats.norm.pdf": {
      "name": "scipy.stats.norm.pdf",
      "type": "callable",
      "signature": "(x, *args, **kwds)",
      "short_docstring": "Probability density function at x of the given RV."
    },
    "scipy.stats.norm.fit": {
      "name": "scipy.stats.norm.fit",
      "type": "callable",
      "signature": "(*args, **kwds)",
      "short_docstring": ""
    }
  },
  "BigCodeBench/553": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "plot": {
          "name": "pandas.DataFrame.plot",
          "type": "class",
          "signature": "()",
          "short_docstring": "Make plots of Series or DataFrame."
        }
      }
    },
    "matplotlib.pyplot.show": {
      "name": "matplotlib.pyplot.show",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Display all open figures."
    },
    "matplotlib.pyplot.close": {
      "name": "matplotlib.pyplot.close",
      "type": "callable",
      "signature": "(fig=None)",
      "short_docstring": "Close a figure window."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "numpy.random.randn": {
      "name": "numpy.random.randn",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "randn(d0, d1, ..., dn)"
    }
  },
  "BigCodeBench/560": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "strptime": {
          "name": "datetime.datetime.strptime",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "string, format -> new datetime parsed from a string (like time.strptime())."
        }
      }
    },
    "d.split('-')": {
      "name": "d.split('-')",
      "error": "Import error: No module named 'd'"
    },
    "d.rsplit('-', 1)": {
      "name": "d.rsplit('-', 1)",
      "error": "Import error: No module named 'd'"
    },
    "data.strip()": {
      "name": "data.strip()",
      "error": "Import error: No module named 'data'"
    },
    "data.split(',')": {
      "name": "data.split(',')",
      "error": "Import error: No module named 'data'"
    },
    "df.set_index.index": {
      "name": "df.set_index.index",
      "error": "Import error: No module named 'df'"
    },
    "df.set_index.set_index('Month')": {
      "name": "df.set_index.set_index('Month')",
      "error": "Import error: No module named 'df'"
    },
    "matplotlib.pyplot.close": {
      "name": "matplotlib.pyplot.close",
      "type": "callable",
      "signature": "(fig=None)",
      "short_docstring": "Close a figure window."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "(**fig_kw)",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.xticks": {
      "name": "matplotlib.pyplot.xticks",
      "type": "callable",
      "signature": "(**kwargs)",
      "short_docstring": "Get or set the current tick locations and labels of the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].bar": {
      "name": "matplotlib.pyplot.subplots[1].bar",
      "type": "method",
      "signature": "(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)",
      "short_docstring": "Make a bar plot."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    }
  },
  "BigCodeBench/567": {
    "data.split.split('-')": {
      "name": "data.split.split('-')",
      "error": "Import error: No module named 'data'"
    },
    "matplotlib.pyplot.gca": {
      "name": "matplotlib.pyplot.gca",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "matplotlib.pyplot.show": {
      "name": "matplotlib.pyplot.show",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Display all open figures."
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "(figsize=None, **kwargs)",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "matplotlib.pyplot.gca.set_xlabel": {
      "name": "matplotlib.pyplot.gca.set_xlabel",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "matplotlib.pyplot.gca.set_ylabel": {
      "name": "matplotlib.pyplot.gca.set_ylabel",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "matplotlib.pyplot.gca.set_title": {
      "name": "matplotlib.pyplot.gca.set_title",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "matplotlib.pyplot.gca.set_xticks": {
      "name": "matplotlib.pyplot.gca.set_xticks",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "matplotlib.pyplot.gca.hist": {
      "name": "matplotlib.pyplot.gca.hist",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "numpy.arange": {
      "name": "numpy.arange",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "arange([start,] stop[, step,], dtype=None, *, like=None)"
    }
  },
  "BigCodeBench/574": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "numpy.pi": {
      "name": "numpy.pi",
      "type": "constant",
      "signature": null,
      "short_docstring": "Convert a string or number to a floating point number, if possible.",
      "value": "3.141592653589793"
    },
    "numpy.sin": {
      "name": "numpy.sin",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "numpy.random.rand": {
      "name": "numpy.random.rand",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "rand(d0, d1, ..., dn)"
    },
    "numpy.linspace": {
      "name": "numpy.linspace",
      "type": "callable",
      "signature": "(start, stop, num=50)",
      "short_docstring": "Return evenly spaced numbers over a specified interval."
    },
    "scipy.optimize.curve_fit": {
      "name": "scipy.optimize.curve_fit",
      "type": "callable",
      "signature": "(f, xdata, ydata, p0=None, **kwargs)",
      "short_docstring": "Use non-linear least squares to fit a function, f, to data."
    }
  },
  "BigCodeBench/579": {
    "collections.Counter": {
      "name": "collections.Counter",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "short_docstring": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.",
      "chains": {
        "most_common": {
          "name": "collections.Counter.most_common",
          "type": "callable",
          "signature": "(self, n=None)",
          "short_docstring": "List the n most common elements and their counts from the most\ncommon to the least.  If n is None, then list all element counts."
        }
      }
    },
    "csv.reader": {
      "name": "csv.reader",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_reader = reader(iterable [, dialect='excel']\n                        [optional keyword args])\n    for row in csv_reader:\n        process(row)"
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].bar": {
      "name": "matplotlib.pyplot.subplots[1].bar",
      "type": "method",
      "signature": "(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)",
      "short_docstring": "Make a bar plot."
    },
    "unicodedata.normalize": {
      "name": "unicodedata.normalize",
      "type": "callable",
      "signature": "(form, unistr)",
      "short_docstring": "Return the normal form 'form' for the Unicode string unistr."
    },
    "words.append(normalized_word)": {
      "name": "words.append(normalized_word)",
      "error": "Import error: No module named 'words'"
    }
  },
  "BigCodeBench/582": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].get_xlim": {
      "name": "matplotlib.pyplot.subplots[1].get_xlim",
      "type": "method",
      "signature": "()",
      "short_docstring": "Return the x-axis view limits."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "matplotlib.pyplot.subplots[1].hist": {
      "name": "matplotlib.pyplot.subplots[1].hist",
      "type": "method",
      "signature": "(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)",
      "short_docstring": "Compute and plot a histogram."
    },
    "numpy.random.randn": {
      "name": "numpy.random.randn",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "randn(d0, d1, ..., dn)"
    },
    "numpy.linspace": {
      "name": "numpy.linspace",
      "type": "callable",
      "signature": "(start, stop, num=50)",
      "short_docstring": "Return evenly spaced numbers over a specified interval."
    },
    "numpy.histogram_bin_edges": {
      "name": "numpy.histogram_bin_edges",
      "type": "callable",
      "signature": "(a, bins=10)",
      "short_docstring": "Function to calculate only the edges of the bins used by the `histogram`\nfunction."
    },
    "scipy.stats.norm": {
      "name": "scipy.stats.norm",
      "type": "callable",
      "signature": "(*args, **kwds)",
      "short_docstring": "A normal continuous random variable."
    },
    "scipy.stats.norm.fit": {
      "name": "scipy.stats.norm.fit",
      "type": "callable",
      "signature": "(*args, **kwds)",
      "short_docstring": ""
    },
    "scipy.stats.norm.pdf": {
      "name": "scipy.stats.norm.pdf",
      "type": "callable",
      "signature": "(x, *args, **kwds)",
      "short_docstring": "Probability density function at x of the given RV."
    }
  },
  "BigCodeBench/583": {
    "Crypto.Cipher.AES.MODE_EAX": {
      "name": "Crypto.Cipher.AES.MODE_EAX",
      "type": "constant",
      "signature": null,
      "short_docstring": "int([x]) -> integer\nint(x, base=10) -> integer",
      "value": "9"
    },
    "Crypto.Cipher.AES.new.nonce": {
      "name": "Crypto.Cipher.AES.new.nonce",
      "type": "callable",
      "signature": "(key, mode, *args, **kwargs)",
      "short_docstring": "Create a new AES cipher."
    },
    "Crypto.Random.get_random_bytes": {
      "name": "Crypto.Random.get_random_bytes",
      "type": "callable",
      "signature": "(size)",
      "short_docstring": "Return a bytes object containing random bytes suitable for cryptographic use."
    },
    "Crypto.Cipher.AES.new": {
      "name": "Crypto.Cipher.AES.new",
      "type": "callable",
      "signature": "(key, mode)",
      "short_docstring": "Create a new AES cipher."
    },
    "Crypto.Cipher.AES.new.encrypt_and_digest": {
      "name": "Crypto.Cipher.AES.new.encrypt_and_digest",
      "type": "callable",
      "signature": "(key)",
      "short_docstring": "Create a new AES cipher."
    },
    "base64.b64encode": {
      "name": "base64.b64encode",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Encode the bytes-like object s using Base64 and return a bytes object."
    },
    "open.write(priv_key_encrypted)": {
      "name": "open.write(priv_key_encrypted)",
      "error": "Import error: No module named 'open'"
    },
    "os.urandom": {
      "name": "os.urandom",
      "type": "callable",
      "signature": "(size)",
      "short_docstring": "Return a bytes object containing random bytes suitable for cryptographic use."
    },
    "rsa.newkeys": {
      "name": "rsa.newkeys",
      "type": "callable",
      "signature": "(nbits: int)",
      "short_docstring": "Generates public and private keys, and returns them as (pub, priv)."
    },
    "rsa.newkeys[1].save_pkcs1": {
      "name": "rsa.newkeys[1].save_pkcs1",
      "error": "newkeys() missing 1 required positional argument: 'nbits'"
    }
  },
  "BigCodeBench/587": {
    "base64.b64encode": {
      "name": "base64.b64encode",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Encode the bytes-like object s using Base64 and return a bytes object."
    },
    "cipher.encryptor.finalize()": {
      "name": "cipher.encryptor.finalize()",
      "error": "Import error: No module named 'cipher'"
    },
    "cipher.encryptor.update(padded_data)": {
      "name": "cipher.encryptor.update(padded_data)",
      "error": "Import error: No module named 'cipher'"
    },
    "cryptography.hazmat.backends.default_backend": {
      "name": "cryptography.hazmat.backends.default_backend",
      "type": "callable",
      "signature": "()",
      "short_docstring": ""
    },
    "cryptography.hazmat.primitives.padding.PKCS7": {
      "name": "cryptography.hazmat.primitives.padding.PKCS7",
      "type": "class",
      "signature": "(block_size: int)",
      "short_docstring": ""
    },
    "cryptography.hazmat.primitives.ciphers.modes.CBC": {
      "name": "cryptography.hazmat.primitives.ciphers.modes.CBC",
      "type": "class",
      "signature": "(initialization_vector: bytes)",
      "short_docstring": ""
    },
    "cryptography.hazmat.primitives.ciphers.Cipher.encryptor": {
      "name": "cryptography.hazmat.primitives.ciphers.Cipher.encryptor",
      "type": "callable",
      "signature": "(self)",
      "short_docstring": ""
    },
    "cryptography.hazmat.primitives.ciphers.algorithms.AES": {
      "name": "cryptography.hazmat.primitives.ciphers.algorithms.AES",
      "type": "class",
      "signature": "(key: bytes)",
      "short_docstring": ""
    },
    "cryptography.hazmat.primitives.padding.PKCS7.padder.finalize": {
      "name": "cryptography.hazmat.primitives.padding.PKCS7.padder.finalize",
      "type": "callable",
      "signature": "()",
      "short_docstring": ""
    },
    "cryptography.hazmat.primitives.padding.PKCS7.padder.update": {
      "name": "cryptography.hazmat.primitives.padding.PKCS7.padder.update",
      "type": "callable",
      "signature": "(self) -> cryptography.hazmat.primitives.padding.PaddingContex)",
      "short_docstring": ""
    },
    "cryptography.hazmat.primitives.ciphers.Cipher": {
      "name": "cryptography.hazmat.primitives.ciphers.Cipher",
      "type": "class",
      "signature": "(algorithm: cryptography.hazmat.primitives._cipheralgorithm.CipherAlgorithm, mode: +Mode, backend: Any = None)",
      "short_docstring": "Abstract base class for generic types."
    },
    "open.read()": {
      "name": "open.read()",
      "error": "Import error: No module named 'open'"
    },
    "open.write(encrypted_data)": {
      "name": "open.write(encrypted_data)",
      "error": "Import error: No module named 'open'"
    },
    "open.write(b64encode(encrypted_aes_key))": {
      "name": "open.write(b64encode(encrypted_aes_key))",
      "error": "Import error: No module named 'open'"
    },
    "os.urandom": {
      "name": "os.urandom",
      "type": "callable",
      "signature": "(size)",
      "short_docstring": "Return a bytes object containing random bytes suitable for cryptographic use."
    },
    "rsa.newkeys": {
      "name": "rsa.newkeys",
      "type": "callable",
      "signature": "(nbits: int)",
      "short_docstring": "Generates public and private keys, and returns them as (pub, priv)."
    },
    "rsa.encrypt": {
      "name": "rsa.encrypt",
      "type": "callable",
      "signature": "(message: bytes, pub_key: rsa.key.PublicKey) -> byte)",
      "short_docstring": "Encrypts the given message using PKCS#1 v1.5"
    }
  },
  "BigCodeBench/590": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "a.text": {
      "name": "a.text",
      "error": "Import error: No module named 'a'"
    },
    "a.get('href')": {
      "name": "a.get('href')",
      "error": "Import error: No module named 'a'"
    },
    "urllib.error.URLError": {
      "name": "urllib.error.URLError",
      "type": "class",
      "signature": "(reason)",
      "short_docstring": "Base class for I/O related errors."
    },
    "urllib.request.urlopen": {
      "name": "urllib.request.urlopen",
      "type": "callable",
      "signature": "(url)",
      "short_docstring": "Open the URL url, which can be either a string or a Request object."
    },
    "urllib.request.urlopen.read": {
      "name": "urllib.request.urlopen.read",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Open the URL url, which can be either a string or a Request object."
    }
  },
  "BigCodeBench/592": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "csv.writer": {
      "name": "csv.writer",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerows": {
      "name": "csv.writer.writerows",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "data.append(row)": {
      "name": "data.append(row)",
      "error": "Import error: No module named 'data'"
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    }
  },
  "BigCodeBench/593": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "csv.writer": {
      "name": "csv.writer",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerows": {
      "name": "csv.writer.writerows",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "data.append(row)": {
      "name": "data.append(row)",
      "error": "Import error: No module named 'data'"
    },
    "matplotlib.pyplot.show": {
      "name": "matplotlib.pyplot.show",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Display all open figures."
    },
    "matplotlib.pyplot.xlabel": {
      "name": "matplotlib.pyplot.xlabel",
      "type": "callable",
      "signature": "(xlabel)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.tight_layout": {
      "name": "matplotlib.pyplot.tight_layout",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Adjust the padding between and around subplots."
    },
    "matplotlib.pyplot.ylabel": {
      "name": "matplotlib.pyplot.ylabel",
      "type": "callable",
      "signature": "(ylabel)",
      "short_docstring": "Set the label for the y-axis."
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "pandas.read_csv.empty": {
      "name": "pandas.read_csv.empty",
      "type": "callable",
      "signature": "(filepath_or_buffer: 'FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]', *, sep: 'str | None | lib.NoDefault' = <no_default>, delimiter: 'str | None | lib.NoDefault' = None, header: \"int | Sequence[int] | None | Literal['infer']\" = 'infer', names: 'Sequence[Hashable] | None | lib.NoDefault' = <no_default>, index_col: 'IndexLabel | Literal[False] | None' = None, usecols=None, dtype: 'DtypeArg | None' = None, engine: 'CSVEngine | None' = None, converters=None, true_values=None, false_values=None, skipinitialspace: 'bool' = False, skiprows=None, skipfooter: 'int' = 0, nrows: 'int | None' = None, na_values=None, keep_default_na: 'bool' = True, na_filter: 'bool' = True, verbose: 'bool' = False, skip_blank_lines: 'bool' = True, parse_dates: 'bool | Sequence[Hashable] | None' = None, infer_datetime_format: 'bool | lib.NoDefault' = <no_default>, keep_date_col: 'bool' = False, date_parser=<no_default>, date_format: 'str | None' = None, dayfirst: 'bool' = False, cache_dates: 'bool' = True, iterator: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', thousands: 'str | None' = None, decimal: 'str' = '.', lineterminator: 'str | None' = None, quotechar: 'str' = '\"', quoting: 'int' = 0, doublequote: 'bool' = True, escapechar: 'str | None' = None, comment: 'str | None' = None, encoding: 'str | None' = None, encoding_errors: 'str | None' = 'strict', dialect: 'str | csv.Dialect | None' = None, on_bad_lines: 'str' = 'error', delim_whitespace: 'bool' = False, low_memory=True, memory_map: 'bool' = False, float_precision: \"Literal['high', 'legacy'] | None\" = None, storage_options: 'StorageOptions' = None, dtype_backend: 'DtypeBackend | lib.NoDefault' = <no_default>) -> 'DataFrame | TextFileReader'",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "pandas.read_csv": {
      "name": "pandas.read_csv",
      "type": "callable",
      "signature": "(filepath_or_buffer: 'FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]')",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "pandas.read_csv.plot": {
      "name": "pandas.read_csv.plot",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    }
  },
  "BigCodeBench/594": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "csv.writer": {
      "name": "csv.writer",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerows": {
      "name": "csv.writer.writerows",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "data.append(row)": {
      "name": "data.append(row)",
      "error": "Import error: No module named 'data'"
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    },
    "shutil.copy": {
      "name": "shutil.copy",
      "type": "callable",
      "signature": "(src, dst)",
      "short_docstring": "Copy data and mode bits (\"cp src dst\"). Return the file's destination."
    }
  },
  "BigCodeBench/618": {
    "match_results.append([team, team_goals, penalty_cost])": {
      "name": "match_results.append([team, team_goals, penalty_cost])",
      "error": "Import error: No module named 'match_results'"
    },
    "matplotlib.pyplot.close": {
      "name": "matplotlib.pyplot.close",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Close a figure window."
    },
    "random.randint": {
      "name": "random.randint",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Return random integer in range [a, b], including both end points.\n        "
    },
    "seaborn.barplot": {
      "name": "seaborn.barplot",
      "type": "callable",
      "signature": "(data=None, x=None, y=None, palette=None, **kwargs)",
      "short_docstring": "Show point estimates and errors as rectangular bars."
    }
  },
  "BigCodeBench/636": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "astype": {
          "name": "pandas.DataFrame.astype",
          "type": "callable",
          "signature": "(self: 'NDFrameT')",
          "short_docstring": "Cast a pandas object to a specified dtype ``dtype``."
        }
      }
    },
    "counts.plot.set_title('Non-Zero Value Counts')": {
      "name": "counts.plot.set_title('Non-Zero Value Counts')",
      "error": "Import error: No module named 'counts'"
    },
    "df.astype(bool).sum.plot(kind='bar')": {
      "name": "df.astype(bool).sum.plot(kind='bar')",
      "error": "Import error: No module named 'sum'"
    },
    "matplotlib.pyplot.gca": {
      "name": "matplotlib.pyplot.gca",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "matplotlib.pyplot.close": {
      "name": "matplotlib.pyplot.close",
      "type": "callable",
      "signature": "(fig=None)",
      "short_docstring": "Close a figure window."
    },
    "matplotlib.pyplot.gca.set_title": {
      "name": "matplotlib.pyplot.gca.set_title",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "numpy.random.randint": {
      "name": "numpy.random.randint",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "randint(low, high=None, size=None, dtype=int)"
    }
  },
  "BigCodeBench/637": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "mean": {
          "name": "pandas.DataFrame.mean",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Return the mean of the values over the requested axis."
        }
      }
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "numpy.random.randint": {
      "name": "numpy.random.randint",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "randint(low, high=None, size=None, dtype=int)"
    },
    "random.sample": {
      "name": "random.sample",
      "type": "callable",
      "signature": "(population, k)",
      "short_docstring": "Chooses k unique random elements from a population sequence or set."
    }
  },
  "BigCodeBench/654": {
    "indices.size": {
      "name": "indices.size",
      "error": "Import error: No module named 'indices'"
    },
    "matplotlib.pyplot.gca": {
      "name": "matplotlib.pyplot.gca",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Get the current Axes."
    },
    "matplotlib.pyplot.show": {
      "name": "matplotlib.pyplot.show",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Display all open figures."
    },
    "matplotlib.pyplot.figure": {
      "name": "matplotlib.pyplot.figure",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a new figure, or activate an existing figure."
    },
    "matplotlib.pyplot.legend": {
      "name": "matplotlib.pyplot.legend",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.plot": {
      "name": "matplotlib.pyplot.plot",
      "type": "callable",
      "signature": "(*args, scalex=True, scaley=True, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "numpy.exp": {
      "name": "numpy.exp",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "numpy.arange": {
      "name": "numpy.arange",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "arange([start,] stop[, step,], dtype=None, *, like=None)"
    },
    "numpy.where": {
      "name": "numpy.where",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "where(condition, [x, y])"
    },
    "numpy.linspace": {
      "name": "numpy.linspace",
      "type": "callable",
      "signature": "(start, stop, num=50)",
      "short_docstring": "Return evenly spaced numbers over a specified interval."
    },
    "scipy.optimize.curve_fit": {
      "name": "scipy.optimize.curve_fit",
      "type": "callable",
      "signature": "(f, xdata, ydata, p0=None, **kwargs)",
      "short_docstring": "Use non-linear least squares to fit a function, f, to data."
    }
  },
  "BigCodeBench/655": {
    "NMF(n_components=num_topics, random_state=1).fit.components_": {
      "name": "NMF(n_components=num_topics, random_state=1).fit.components_",
      "error": "Import error: No module named 'fit'"
    },
    "nltk.corpus.stopwords": {
      "name": "nltk.corpus.stopwords",
      "type": "constant",
      "signature": null,
      "short_docstring": "To see the API documentation for this lazily loaded corpus, first\nrun corpus.ensure_loaded(), and then run help(this_corpus).",
      "value": "<WordListCorpusReader in '.../corpora/stopwords' (not loaded yet)>"
    },
    "nltk.download": {
      "name": "nltk.download",
      "type": "callable",
      "signature": "(info_or_id=None)",
      "short_docstring": ""
    },
    "nltk.corpus.stopwords.words": {
      "name": "nltk.corpus.stopwords.words",
      "type": "callable",
      "signature": "(fileids=None)",
      "short_docstring": ""
    },
    "re.compile": {
      "name": "re.compile",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    },
    "re.compile.sub": {
      "name": "re.compile.sub",
      "type": "callable",
      "signature": "(pattern, flags=0)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    },
    "sklearn.decomposition.NMF": {
      "name": "sklearn.decomposition.NMF",
      "type": "class",
      "signature": "(n_components=None, random_state=None)",
      "short_docstring": "Non-Negative Matrix Factorization (NMF)."
    },
    "sklearn.feature_extraction.text.TfidfVectorizer.get_feature_names": {
      "name": "sklearn.feature_extraction.text.TfidfVectorizer.get_feature_names",
      "type": "class",
      "signature": "()",
      "short_docstring": "Convert a collection of raw documents to a matrix of TF-IDF features."
    },
    "sklearn.feature_extraction.text.TfidfVectorizer.get_feature_names_out": {
      "name": "sklearn.feature_extraction.text.TfidfVectorizer.get_feature_names_out",
      "type": "callable",
      "signature": "(self)",
      "short_docstring": "Get output feature names for transformation."
    },
    "sklearn.feature_extraction.text.TfidfVectorizer.fit_transform": {
      "name": "sklearn.feature_extraction.text.TfidfVectorizer.fit_transform",
      "type": "callable",
      "signature": "(self, raw_documents)",
      "short_docstring": "Learn vocabulary and idf, return document-term matrix."
    },
    "sklearn.feature_extraction.text.TfidfVectorizer": {
      "name": "sklearn.feature_extraction.text.TfidfVectorizer",
      "type": "class",
      "signature": "(stop_words=None, max_df=1.0, min_df=1)",
      "short_docstring": "Convert a collection of raw documents to a matrix of TF-IDF features."
    },
    "text.split()": {
      "name": "text.split()",
      "error": "Import error: No module named 'text'"
    },
    "topic.argsort()": {
      "name": "topic.argsort()",
      "error": "Import error: No module named 'topic'"
    },
    "topics.append(topic_keywords)": {
      "name": "topics.append(topic_keywords)",
      "error": "Import error: No module named 'topics'"
    }
  },
  "BigCodeBench/657": {
    "gensim.models.Word2Vec": {
      "name": "gensim.models.Word2Vec",
      "type": "class",
      "signature": "(sentences=None, vector_size=100, window=5, min_count=5, workers=3)",
      "short_docstring": "Serialize/deserialize objects from disk, by equipping them with the `save()` / `load()` methods."
    },
    "nltk.corpus.stopwords": {
      "name": "nltk.corpus.stopwords",
      "type": "constant",
      "signature": null,
      "short_docstring": "List of words, one per line.  Blank lines are ignored.",
      "value": "<WordListCorpusReader in '/home/terryz1/nltk_data/corpora/stopwords'>"
    },
    "nltk.corpus.stopwords.words": {
      "name": "nltk.corpus.stopwords.words",
      "type": "callable",
      "signature": "(fileids=None)",
      "short_docstring": ""
    },
    "re.compile": {
      "name": "re.compile",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    },
    "re.compile.sub": {
      "name": "re.compile.sub",
      "type": "callable",
      "signature": "(pattern, flags=0)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    },
    "text.split()": {
      "name": "text.split()",
      "error": "Import error: No module named 'text'"
    }
  },
  "BigCodeBench/678": {
    "filename.endswith('.json')": {
      "name": "filename.endswith('.json')",
      "error": "Import error: No module named 'filename'"
    },
    "json.load": {
      "name": "json.load",
      "type": "callable",
      "signature": "(fp)",
      "short_docstring": "Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\na JSON document) to a Python object."
    },
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "pandas.concat": {
      "name": "pandas.concat",
      "type": "callable",
      "signature": "(objs: 'Iterable[NDFrame] | Mapping[HashableT)",
      "short_docstring": "Concatenate pandas objects along a particular axis."
    },
    "shutil.move": {
      "name": "shutil.move",
      "type": "callable",
      "signature": "(src, dst)",
      "short_docstring": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command. Return the file or directory's\ndestination."
    }
  },
  "BigCodeBench/720": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "csv.writer": {
      "name": "csv.writer",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerow": {
      "name": "csv.writer.writerow",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "os.path.isfile": {
      "name": "os.path.isfile",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path is a regular file"
    },
    "os.path.dirname": {
      "name": "os.path.dirname",
      "type": "callable",
      "signature": "(p)",
      "short_docstring": "Returns the directory component of a pathname"
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name, exist_ok=False)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "random.uniform": {
      "name": "random.uniform",
      "type": "callable",
      "signature": "(a, b)",
      "short_docstring": "Get a random number in the range [a, b) or [a, b] depending on rounding."
    }
  },
  "BigCodeBench/723": {
    "bs4.BeautifulSoup": {
      "name": "bs4.BeautifulSoup",
      "type": "class",
      "signature": "(markup='', features=None, builder=None, parse_only=None, from_encoding=None, exclude_encodings=None, element_classes=None, **kwargs)",
      "short_docstring": "A data structure representing a parsed HTML or XML document.",
      "chains": {
        "find": {
          "name": "bs4.BeautifulSoup.find",
          "type": "callable",
          "signature": "(self, name=None, attrs={}, **kwargs)",
          "short_docstring": "Look in the children of this PageElement and find the first\nPageElement that matches the given criteria."
        }
      }
    },
    "csv.writer": {
      "name": "csv.writer",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerows": {
      "name": "csv.writer.writerows",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "data.append(row)": {
      "name": "data.append(row)",
      "error": "Import error: No module named 'data'"
    },
    "os.remove": {
      "name": "os.remove",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Remove a file (same as unlink())."
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "soup.find.find_all('tr')": {
      "name": "soup.find.find_all('tr')",
      "error": "Import error: No module named 'soup'"
    },
    "tr.text": {
      "name": "tr.text",
      "error": "Import error: No module named 'tr'"
    },
    "tr.find_all('td')": {
      "name": "tr.find_all('td')",
      "error": "Import error: No module named 'tr'"
    },
    "urllib.request.urlopen": {
      "name": "urllib.request.urlopen",
      "type": "callable",
      "signature": "(url)",
      "short_docstring": "Open the URL url, which can be either a string or a Request object."
    }
  },
  "BigCodeBench/752": {
    "LinearRegression().fit.score(X_test, y_test)": {
      "name": "LinearRegression().fit.score(X_test, y_test)",
      "error": "Import error: No module named 'fit'"
    },
    "data.empty": {
      "name": "data.empty",
      "error": "Import error: No module named 'data'"
    },
    "data.dtypes": {
      "name": "data.dtypes",
      "error": "Import error: No module named 'data'"
    },
    "data.columns": {
      "name": "data.columns",
      "error": "Import error: No module named 'data'"
    },
    "data.drop(columns=[target_column])": {
      "name": "data.drop(columns=[target_column])",
      "error": "Import error: No module named 'data'"
    },
    "numpy.issubdtype": {
      "name": "numpy.issubdtype",
      "type": "callable",
      "signature": "(arg1, arg2)",
      "short_docstring": "Returns True if first argument is a typecode lower/equal in type hierarchy."
    },
    "sklearn.linear_model.LinearRegression": {
      "name": "sklearn.linear_model.LinearRegression",
      "type": "class",
      "signature": "()",
      "short_docstring": "Ordinary least squares Linear Regression."
    },
    "sklearn.model_selection.train_test_split": {
      "name": "sklearn.model_selection.train_test_split",
      "type": "callable",
      "signature": "(*arrays, test_size=None, random_state=None)",
      "short_docstring": "Split arrays or matrices into random train and test subsets."
    }
  },
  "BigCodeBench/760": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "datetime": {
          "name": "datetime.datetime.datetime",
          "type": "class",
          "signature": "(self, /, *args, **kwargs)",
          "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])"
        }
      }
    },
    "codecs.encode": {
      "name": "codecs.encode",
      "type": "callable",
      "signature": "(obj, encoding='utf-8')",
      "short_docstring": "Encodes obj using the codec registered for encoding."
    },
    "data.append([i, name, dob, email])": {
      "name": "data.append([i, name, dob, email])",
      "error": "Import error: No module named 'data'"
    },
    "name.lower()": {
      "name": "name.lower()",
      "error": "Import error: No module named 'name'"
    },
    "numpy.random.randint": {
      "name": "numpy.random.randint",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "randint(low, high=None, size=None, dtype=int)"
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "numpy.random.choice": {
      "name": "numpy.random.choice",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "choice(a, size=None, replace=True, p=None)"
    },
    "re.sub": {
      "name": "re.sub",
      "type": "callable",
      "signature": "(pattern, repl, string)",
      "short_docstring": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used."
    }
  },
  "BigCodeBench/763": {
    "collections.defaultdict": {
      "name": "collections.defaultdict",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "defaultdict(default_factory=None, /, [...]) --> dict with default factory",
      "chains": {
        "items": {
          "name": "collections.defaultdict.items",
          "type": "callable",
          "signature": "()",
          "short_docstring": "D.items() -> a set-like object providing a view on D's items"
        }
      }
    },
    "csv.DictWriter": {
      "name": "csv.DictWriter",
      "type": "class",
      "signature": "(f, fieldnames, restval='', extrasaction='raise', dialect='excel', *args, **kwds)",
      "short_docstring": "",
      "chains": {
        "writeheader": {
          "name": "csv.DictWriter.writeheader",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": ""
        },
        "writerow": {
          "name": "csv.DictWriter.writerow",
          "type": "callable",
          "signature": "(self, rowdict)",
          "short_docstring": ""
        }
      }
    },
    "d.items()": {
      "name": "d.items()",
      "error": "Import error: No module named 'd'"
    },
    "json.load": {
      "name": "json.load",
      "type": "callable",
      "signature": "(fp)",
      "short_docstring": "Deserialize ``fp`` (a ``.read()``-supporting file-like object containing\na JSON document) to a Python object."
    },
    "numpy.mean": {
      "name": "numpy.mean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis."
    },
    "numpy.median": {
      "name": "numpy.median",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the median along the specified axis."
    },
    "result.items()": {
      "name": "result.items()",
      "error": "Import error: No module named 'result'"
    }
  },
  "BigCodeBench/765": {
    "copied_files.append(str(target_file))": {
      "name": "copied_files.append(str(target_file))",
      "error": "Import error: No module named 'copied_files'"
    },
    "kwargs.items()": {
      "name": "kwargs.items()",
      "error": "Import error: No module named 'kwargs'"
    },
    "os.path.isfile": {
      "name": "os.path.isfile",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path is a regular file"
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "shutil.copyfile": {
      "name": "shutil.copyfile",
      "type": "callable",
      "signature": "(src, dst)",
      "short_docstring": "Copy data from src to dst in the most efficient way possible."
    }
  },
  "BigCodeBench/771": {
    "csv.reader": {
      "name": "csv.reader",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_reader = reader(iterable [, dialect='excel']\n                        [optional keyword args])\n    for row in csv_reader:\n        process(row)"
    },
    "csv.writer": {
      "name": "csv.writer",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerows": {
      "name": "csv.writer.writerows",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "file_pattern.match.group(1)": {
      "name": "file_pattern.match.group(1)",
      "error": "Import error: No module named 'file_pattern'"
    },
    "new_files.append(new_filename)": {
      "name": "new_files.append(new_filename)",
      "error": "Import error: No module named 'new_files'"
    },
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "re.compile": {
      "name": "re.compile",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    },
    "re.compile.match": {
      "name": "re.compile.match",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    }
  },
  "BigCodeBench/777": {
    "zipfile.ZipFile": {
      "name": "zipfile.ZipFile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "short_docstring": "Class with methods to open, read, write, close, list zip files.",
      "chains": {
        "extractall": {
          "name": "zipfile.ZipFile.extractall",
          "type": "callable",
          "signature": "(self, path=None)",
          "short_docstring": "Extract all members from the archive to the current working\ndirectory. `path' specifies a different directory to extract to.\n`members' is optional and must be a subset of the list returned\nby namelist()."
        }
      }
    },
    "extracted_dirs.append(extract_path)": {
      "name": "extracted_dirs.append(extract_path)",
      "error": "Import error: No module named 'extracted_dirs'"
    },
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name, exist_ok=False)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "re.match.group": {
      "name": "re.match.group",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Try to apply the pattern at the start of the string, returning\na Match object, or None if no match was found."
    },
    "re.match": {
      "name": "re.match",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Try to apply the pattern at the start of the string, returning\na Match object, or None if no match was found."
    }
  },
  "BigCodeBench/785": {
    "glob.glob": {
      "name": "glob.glob",
      "type": "callable",
      "signature": "(pathname)",
      "short_docstring": "Return a list of paths matching a pathname pattern."
    },
    "os.remove": {
      "name": "os.remove",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Remove a file (same as unlink())."
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "subprocess.run": {
      "name": "subprocess.run",
      "type": "callable",
      "signature": "(*popenargs)",
      "short_docstring": "Run command with arguments and return a CompletedProcess instance."
    }
  },
  "BigCodeBench/800": {
    "csv.writer": {
      "name": "csv.writer",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerows": {
      "name": "csv.writer.writerows",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "goals.items()": {
      "name": "goals.items()",
      "error": "Import error: No module named 'goals'"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "penalties.items()": {
      "name": "penalties.items()",
      "error": "Import error: No module named 'penalties'"
    },
    "row.get('goals', 0)": {
      "name": "row.get('goals', 0)",
      "error": "Import error: No module named 'row'"
    },
    "row.get('penalties', 0)": {
      "name": "row.get('penalties', 0)",
      "error": "Import error: No module named 'row'"
    }
  },
  "BigCodeBench/826": {
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "re.match": {
      "name": "re.match",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Try to apply the pattern at the start of the string, returning\na Match object, or None if no match was found."
    },
    "shutil.move": {
      "name": "shutil.move",
      "type": "callable",
      "signature": "(src, dst)",
      "short_docstring": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command. Return the file or directory's\ndestination."
    }
  },
  "BigCodeBench/845": {
    "collections.Counter": {
      "name": "collections.Counter",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "short_docstring": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.",
      "chains": {
        "keys": {
          "name": "collections.Counter.keys",
          "type": "callable",
          "signature": "()",
          "short_docstring": "D.keys() -> a set-like object providing a view on D's keys"
        }
      }
    },
    "ALPHANUMERIC.sub(' ', text2).lower.split()": {
      "name": "ALPHANUMERIC.sub(' ', text2).lower.split()",
      "error": "Import error: No module named 'lower'"
    },
    "ALPHANUMERIC.sub(' ', text1).lower.split()": {
      "name": "ALPHANUMERIC.sub(' ', text1).lower.split()",
      "error": "Import error: No module named 'lower'"
    },
    "Levenshtein.ratio": {
      "name": "Levenshtein.ratio",
      "type": "callable",
      "signature": "(s1, s2)",
      "short_docstring": "Calculates a normalized indel similarity in the range [0, 1].\nThe indel distance calculates the minimum number of insertions and deletions\nrequired to change one sequence into the other."
    },
    "numpy.sqrt": {
      "name": "numpy.sqrt",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "re.compile": {
      "name": "re.compile",
      "type": "callable",
      "signature": "(pattern)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    },
    "re.compile.sub": {
      "name": "re.compile.sub",
      "type": "callable",
      "signature": "(pattern, flags=0)",
      "short_docstring": "Compile a regular expression pattern, returning a Pattern object."
    }
  },
  "BigCodeBench/854": {
    "functools.reduce": {
      "name": "functools.reduce",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "reduce(function, iterable[, initial]) -> value"
    },
    "math.factorial": {
      "name": "math.factorial",
      "type": "callable",
      "signature": "(x)",
      "short_docstring": "Find x!."
    }
  },
  "BigCodeBench/857": {
    "glob.glob": {
      "name": "glob.glob",
      "type": "callable",
      "signature": "(pathname)",
      "short_docstring": "Return a list of paths matching a pathname pattern."
    },
    "os.path.basename": {
      "name": "os.path.basename",
      "type": "callable",
      "signature": "(p)",
      "short_docstring": "Returns the final component of a pathname"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "shutil.move": {
      "name": "shutil.move",
      "type": "callable",
      "signature": "(src, dst)",
      "short_docstring": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command. Return the file or directory's\ndestination."
    },
    "time.sleep": {
      "name": "time.sleep",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "sleep(seconds)"
    },
    "transferred_files.append(os.path.basename(src_file))": {
      "name": "transferred_files.append(os.path.basename(src_file))",
      "error": "Import error: No module named 'transferred_files'"
    },
    "warnings.simplefilter": {
      "name": "warnings.simplefilter",
      "type": "callable",
      "signature": "(action)",
      "short_docstring": "Insert a simple entry into the list of warnings filters (at the front)."
    },
    "warnings.warn": {
      "name": "warnings.warn",
      "type": "callable",
      "signature": "(message)",
      "short_docstring": "Issue a warning, or maybe ignore it or raise an exception."
    }
  },
  "BigCodeBench/865": {
    "numpy.array": {
      "name": "numpy.array",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    },
    "scipy.stats.zscore": {
      "name": "scipy.stats.zscore",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the z score."
    },
    "sklearn.preprocessing.MinMaxScaler": {
      "name": "sklearn.preprocessing.MinMaxScaler",
      "type": "class",
      "signature": "()",
      "short_docstring": "Transform features by scaling each feature to a given range."
    },
    "sklearn.preprocessing.MinMaxScaler.fit_transform": {
      "name": "sklearn.preprocessing.MinMaxScaler.fit_transform",
      "type": "callable",
      "signature": "(self, X)",
      "short_docstring": "Fit to data, then transform it."
    }
  },
  "BigCodeBench/870": {
    "mean_values.append(np.nan)": {
      "name": "mean_values.append(np.nan)",
      "error": "Import error: No module named 'mean_values'"
    },
    "mean_values.append(np.nanmean(numeric_values))": {
      "name": "mean_values.append(np.nanmean(numeric_values))",
      "error": "Import error: No module named 'mean_values'"
    },
    "numpy.nan": {
      "name": "numpy.nan",
      "type": "constant",
      "signature": null,
      "short_docstring": "Convert a string or number to a floating point number, if possible.",
      "value": "nan"
    },
    "numpy.nanmean": {
      "name": "numpy.nanmean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis, ignoring NaNs."
    }
  },
  "BigCodeBench/879": {
    "data.empty": {
      "name": "data.empty",
      "error": "Import error: No module named 'data'"
    },
    "numpy.issubdtype": {
      "name": "numpy.issubdtype",
      "type": "callable",
      "signature": "(arg1, arg2)",
      "short_docstring": "Returns True if first argument is a typecode lower/equal in type hierarchy."
    },
    "pandas.crosstab": {
      "name": "pandas.crosstab",
      "type": "callable",
      "signature": "(index, columns)",
      "short_docstring": "Compute a simple cross tabulation of two (or more) factors."
    },
    "scipy.stats.chi2_contingency": {
      "name": "scipy.stats.chi2_contingency",
      "type": "callable",
      "signature": "(observed)",
      "short_docstring": "Chi-square test of independence of variables in a contingency table."
    }
  },
  "BigCodeBench/897": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].hist": {
      "name": "matplotlib.pyplot.subplots[1].hist",
      "type": "method",
      "signature": "(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype='bar', align='mid', orientation='vertical', rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)",
      "short_docstring": "Compute and plot a histogram."
    },
    "numpy.arange": {
      "name": "numpy.arange",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "arange([start,] stop[, step,], dtype=None, *, like=None)"
    },
    "numpy.bincount": {
      "name": "numpy.bincount",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "bincount(x, weights=None, minlength=0)"
    },
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "random.choice": {
      "name": "random.choice",
      "type": "callable",
      "signature": "(seq)",
      "short_docstring": "Choose a random element from a non-empty sequence."
    }
  },
  "BigCodeBench/906": {
    "zipfile.ZipFile": {
      "name": "zipfile.ZipFile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "short_docstring": "Class with methods to open, read, write, close, list zip files.",
      "chains": {
        "write": {
          "name": "zipfile.ZipFile.write",
          "type": "callable",
          "signature": "(self, filename, arcname=None)",
          "short_docstring": "Put the bytes from filename into the archive under the name\narcname."
        }
      }
    },
    "os.path.splitext": {
      "name": "os.path.splitext",
      "type": "callable",
      "signature": "(p)",
      "short_docstring": "Split the extension from a pathname."
    },
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name, exist_ok=False)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "re.search": {
      "name": "re.search",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Scan through string looking for a match to the pattern, returning\na Match object, or None if no match was found."
    },
    "shutil.move": {
      "name": "shutil.move",
      "type": "callable",
      "signature": "(src, dst)",
      "short_docstring": "Recursively move a file or directory to another location. This is\nsimilar to the Unix \"mv\" command. Return the file or directory's\ndestination."
    }
  },
  "BigCodeBench/914": {
    "pandas.Timestamp": {
      "name": "pandas.Timestamp",
      "type": "class",
      "signature": "(ts_input=<object object at 0x7f3e4f45a440>, year=None, month=None, day=None, hour=None, minute=None, second=None, microsecond=None, tzinfo=None, *, nanosecond=None, tz=None, unit=None, fold=None)",
      "short_docstring": "Pandas replacement for python datetime.datetime object.",
      "chains": {
        "timestamp": {
          "name": "pandas.Timestamp.timestamp",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "Return POSIX timestamp as float."
        }
      }
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].scatter": {
      "name": "matplotlib.pyplot.subplots[1].scatter",
      "type": "method",
      "signature": "(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)",
      "short_docstring": "A scatter plot of *y* vs. *x* with varying marker size and/or color."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "numpy.array": {
      "name": "numpy.array",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    },
    "pandas.to_datetime": {
      "name": "pandas.to_datetime",
      "type": "callable",
      "signature": "(arg: 'DatetimeScalarOrArrayConvertible | DictConvertible')",
      "short_docstring": "Convert argument to datetime."
    },
    "sklearn.linear_model.LinearRegression": {
      "name": "sklearn.linear_model.LinearRegression",
      "type": "class",
      "signature": "()",
      "short_docstring": "Ordinary least squares Linear Regression."
    },
    "sklearn.linear_model.LinearRegression.fit": {
      "name": "sklearn.linear_model.LinearRegression.fit",
      "type": "callable",
      "signature": "(self, X, y)",
      "short_docstring": "Fit linear model."
    },
    "sklearn.linear_model.LinearRegression.predict": {
      "name": "sklearn.linear_model.LinearRegression.predict",
      "type": "callable",
      "signature": "(self, X)",
      "short_docstring": "Predict using the linear model."
    }
  },
  "BigCodeBench/915": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "(**fig_kw)",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "numpy.abs": {
      "name": "numpy.abs",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "scipy.stats.zscore": {
      "name": "scipy.stats.zscore",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the z score."
    }
  },
  "BigCodeBench/916": {
    "matplotlib.pyplot.close": {
      "name": "matplotlib.pyplot.close",
      "type": "callable",
      "signature": "(fig=None)",
      "short_docstring": "Close a figure window."
    },
    "matplotlib.pyplot.tight_layout": {
      "name": "matplotlib.pyplot.tight_layout",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Adjust the padding between and around subplots."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "(nrows=1, ncols=1, **fig_kw)",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "seaborn.boxplot": {
      "name": "seaborn.boxplot",
      "type": "callable",
      "signature": "(x=None, ax=None, **kwargs)",
      "short_docstring": "Draw a box plot to show distributions with respect to categories."
    },
    "seaborn.boxplot.set_title": {
      "name": "seaborn.boxplot.set_title",
      "type": "callable",
      "signature": "(data=None)",
      "short_docstring": "Draw a box plot to show distributions with respect to categories."
    },
    "seaborn.histplot.set_title": {
      "name": "seaborn.histplot.set_title",
      "type": "callable",
      "signature": "(data=None)",
      "short_docstring": "Plot univariate or bivariate histograms to show distributions of datasets."
    },
    "seaborn.histplot": {
      "name": "seaborn.histplot",
      "type": "callable",
      "signature": "(data=None, kde=False, ax=None, **kwargs)",
      "short_docstring": "Plot univariate or bivariate histograms to show distributions of datasets."
    }
  },
  "BigCodeBench/917": {
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].legend": {
      "name": "matplotlib.pyplot.subplots[1].legend",
      "type": "method",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Place a legend on the Axes."
    },
    "matplotlib.pyplot.subplots[1].plot": {
      "name": "matplotlib.pyplot.subplots[1].plot",
      "type": "method",
      "signature": "(*args, scalex=True, scaley=True, data=None, **kwargs)",
      "short_docstring": "Plot y versus x as lines and/or markers."
    },
    "model_fit.forecast.tolist()": {
      "name": "model_fit.forecast.tolist()",
      "error": "Import error: No module named 'model_fit'"
    },
    "pandas.date_range": {
      "name": "pandas.date_range",
      "type": "callable",
      "signature": "(start=None, periods=None, **kwargs) -> 'DatetimeIndex)",
      "short_docstring": "Return a fixed frequency DatetimeIndex."
    },
    "statsmodels.tsa.arima.model.ARIMA.fit": {
      "name": "statsmodels.tsa.arima.model.ARIMA.fit",
      "type": "callable",
      "signature": "(self)",
      "short_docstring": "Fit (estimate) the parameters of the model."
    },
    "statsmodels.tsa.arima.model.ARIMA": {
      "name": "statsmodels.tsa.arima.model.ARIMA",
      "type": "class",
      "signature": "(endog, order=(0)",
      "short_docstring": "Autoregressive Integrated Moving Average (ARIMA) model, and extensions"
    },
    "typing.List": {
      "name": "typing.List",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "A generic version of list."
    },
    "typing.Tuple": {
      "name": "typing.Tuple",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Tuple type; Tuple[X, Y] is the cross-product type of X and Y."
    }
  },
  "BigCodeBench/928": {
    "collections.Counter": {
      "name": "collections.Counter",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "short_docstring": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.",
      "chains": {
        "get": {
          "name": "collections.Counter.get",
          "type": "callable",
          "signature": "(self, key, default=None)",
          "short_docstring": "Return the value for key if key is in the dictionary, else default."
        }
      }
    },
    "string.ascii_lowercase": {
      "name": "string.ascii_lowercase",
      "type": "constant",
      "signature": null,
      "short_docstring": "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str",
      "value": "abcdefghijklmnopqrstuvwxyz"
    }
  },
  "BigCodeBench/942": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "pivot": {
          "name": "pandas.DataFrame.pivot",
          "type": "callable",
          "signature": "(self, columns, index=typing.Literal[<no_default>], values=typing.Literal[<no_default>]) -> 'DataFrame)",
          "short_docstring": "Return reshaped DataFrame organized by given index / column values."
        }
      }
    },
    "matplotlib.pyplot.subplots[1].grid": {
      "name": "matplotlib.pyplot.subplots[1].grid",
      "type": "method",
      "signature": "(visible=None, which='major', axis='both', **kwargs)",
      "short_docstring": "Configure the grid lines."
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "(**fig_kw)",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "numpy.random.seed": {
      "name": "numpy.random.seed",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "seed(self, seed=None)"
    },
    "numpy.random.randint": {
      "name": "numpy.random.randint",
      "type": "callable",
      "signature": "(**kwargs)",
      "short_docstring": "randint(low, high=None, size=None, dtype=int)"
    },
    "pandas.date_range": {
      "name": "pandas.date_range",
      "type": "callable",
      "signature": "(start=None, periods=None, freq=None, **kwargs) -> 'DatetimeIndex)",
      "short_docstring": "Return a fixed frequency DatetimeIndex."
    },
    "report_data.append([date, category, sales])": {
      "name": "report_data.append([date, category, sales])",
      "error": "Import error: No module named 'report_data'"
    }
  },
  "BigCodeBench/945": {
    "numpy.arange": {
      "name": "numpy.arange",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "arange([start,] stop[, step,], dtype=None, *, like=None)"
    },
    "numpy.random.randint": {
      "name": "numpy.random.randint",
      "type": "callable",
      "signature": "(**kwargs)",
      "short_docstring": "randint(low, high=None, size=None, dtype=int)"
    },
    "pandas.date_range": {
      "name": "pandas.date_range",
      "type": "callable",
      "signature": "(start=None, periods=None, freq=None, **kwargs) -> 'DatetimeIndex)",
      "short_docstring": "Return a fixed frequency DatetimeIndex."
    },
    "sklearn.linear_model.LinearRegression": {
      "name": "sklearn.linear_model.LinearRegression",
      "type": "class",
      "signature": "()",
      "short_docstring": "Ordinary least squares Linear Regression."
    },
    "sklearn.linear_model.LinearRegression.fit": {
      "name": "sklearn.linear_model.LinearRegression.fit",
      "type": "callable",
      "signature": "(self, X, y)",
      "short_docstring": "Fit linear model."
    },
    "sklearn.linear_model.LinearRegression.predict": {
      "name": "sklearn.linear_model.LinearRegression.predict",
      "type": "callable",
      "signature": "(self, X)",
      "short_docstring": "Predict using the linear model."
    }
  },
  "BigCodeBench/952": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "today": {
          "name": "datetime.datetime.today",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Current date or datetime:  same as self.__class__.fromtimestamp(time.time())."
        }
      }
    },
    "assignment_data.append([task_name, employee, due_date])": {
      "name": "assignment_data.append([task_name, employee, due_date])",
      "error": "Import error: No module named 'assignment_data'"
    },
    "random.seed": {
      "name": "random.seed",
      "type": "callable",
      "signature": "(a=None)",
      "short_docstring": "Initialize internal state from a seed."
    },
    "random.choice": {
      "name": "random.choice",
      "type": "callable",
      "signature": "(seq)",
      "short_docstring": "Choose a random element from a non-empty sequence."
    }
  },
  "BigCodeBench/955": {
    "collections.Counter": {
      "name": "collections.Counter",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "short_docstring": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.",
      "chains": {
        "items": {
          "name": "collections.Counter.items",
          "type": "callable",
          "signature": "()",
          "short_docstring": "D.items() -> a set-like object providing a view on D's items"
        }
      }
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_xticks": {
      "name": "matplotlib.pyplot.subplots[1].set_xticks",
      "type": "method",
      "signature": "(ticks, labels=None, *, minor=False, **kwargs)",
      "short_docstring": "Set the xaxis' tick locations and optionally labels."
    },
    "matplotlib.pyplot.subplots[1].set_xticklabels": {
      "name": "matplotlib.pyplot.subplots[1].set_xticklabels",
      "type": "method",
      "signature": "(labels, *, minor=False, fontdict=None, **kwargs)",
      "short_docstring": "[*Discouraged*] Set the xaxis' tick labels with list of string labels."
    },
    "matplotlib.pyplot.subplots[1].bar": {
      "name": "matplotlib.pyplot.subplots[1].bar",
      "type": "method",
      "signature": "(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)",
      "short_docstring": "Make a bar plot."
    },
    "numpy.arange": {
      "name": "numpy.arange",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "arange([start,] stop[, step,], dtype=None, *, like=None)"
    },
    "re.IGNORECASE": {
      "name": "re.IGNORECASE",
      "type": "constant",
      "signature": null,
      "short_docstring": "An enumeration.",
      "value": "re.IGNORECASE"
    },
    "re.sub.split": {
      "name": "re.sub.split",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used."
    },
    "re.sub": {
      "name": "re.sub",
      "type": "callable",
      "signature": "(pattern, repl, string, flags=0)",
      "short_docstring": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used."
    },
    "word.replace(' ', '_')": {
      "name": "word.replace(' ', '_')",
      "error": "Import error: No module named 'word'"
    }
  },
  "BigCodeBench/963": {
    "zipfile.ZipFile": {
      "name": "zipfile.ZipFile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "short_docstring": "Class with methods to open, read, write, close, list zip files.",
      "chains": {
        "write": {
          "name": "zipfile.ZipFile.write",
          "type": "callable",
          "signature": "(self, filename, arcname=None)",
          "short_docstring": "Put the bytes from filename into the archive under the name\narcname."
        }
      }
    },
    "glob.glob": {
      "name": "glob.glob",
      "type": "callable",
      "signature": "(pathname, recursive=False)",
      "short_docstring": "Return a list of paths matching a pathname pattern."
    },
    "os.path.abspath": {
      "name": "os.path.abspath",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Return an absolute path."
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name, exist_ok=False)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "zip_name.strip()": {
      "name": "zip_name.strip()",
      "error": "Import error: No module named 'zip_name'"
    }
  },
  "BigCodeBench/964": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "to_csv": {
          "name": "pandas.DataFrame.to_csv",
          "type": "callable",
          "signature": "(self, path_or_buf: 'FilePath | WriteBuffer[bytes] | WriteBuffer[str] | None' = None, index: 'bool_t' = True)",
          "short_docstring": "Write object to a comma-separated values (csv) file."
        }
      }
    },
    "docx.Document": {
      "name": "docx.Document",
      "type": "callable",
      "signature": "(docx: 'str | IO[bytes] | None' = None)",
      "short_docstring": "Return a |Document| object loaded from `docx`, where `docx` can be either a path\nto a ``.docx`` file (a string) or a file-like object."
    },
    "docx.Document.paragraphs": {
      "name": "docx.Document.paragraphs",
      "type": "callable",
      "signature": "(docx: 'str | IO[bytes] | None' = None)",
      "short_docstring": "Return a |Document| object loaded from `docx`, where `docx` can be either a path\nto a ``.docx`` file (a string) or a file-like object."
    },
    "open.readlines()": {
      "name": "open.readlines()",
      "error": "Import error: No module named 'open'"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "os.walk": {
      "name": "os.walk",
      "type": "callable",
      "signature": "(top)",
      "short_docstring": "Directory tree generator."
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name, exist_ok=False)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "p.text": {
      "name": "p.text",
      "error": "Import error: No module named 'p'"
    },
    "pandas.read_csv": {
      "name": "pandas.read_csv",
      "type": "callable",
      "signature": "(filepath_or_buffer: 'FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]')",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "pandas.read_excel": {
      "name": "pandas.read_excel",
      "type": "callable",
      "signature": "(io, engine: \"Literal['xlrd')",
      "short_docstring": "Read an Excel file into a pandas DataFrame."
    }
  },
  "BigCodeBench/969": {
    "df.shape": {
      "name": "df.shape",
      "error": "Import error: No module named 'df'"
    },
    "df.empty": {
      "name": "df.empty",
      "error": "Import error: No module named 'df'"
    },
    "df.columns": {
      "name": "df.columns",
      "error": "Import error: No module named 'df'"
    },
    "df.cumsum()": {
      "name": "df.cumsum()",
      "error": "Import error: No module named 'df'"
    },
    "df.isnull()": {
      "name": "df.isnull()",
      "error": "Import error: No module named 'df'"
    },
    "df.select_dtypes(include=np.number)": {
      "name": "df.select_dtypes(include=np.number)",
      "error": "Import error: No module named 'df'"
    },
    "sklearn.preprocessing.MinMaxScaler": {
      "name": "sklearn.preprocessing.MinMaxScaler",
      "type": "class",
      "signature": "()",
      "short_docstring": "Transform features by scaling each feature to a given range."
    },
    "sklearn.preprocessing.MinMaxScaler.fit_transform": {
      "name": "sklearn.preprocessing.MinMaxScaler.fit_transform",
      "type": "callable",
      "signature": "(self, X)",
      "short_docstring": "Fit to data, then transform it."
    }
  },
  "BigCodeBench/971": {
    "datetime.timezone": {
      "name": "datetime.timezone",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "Fixed offset from UTC implementation of tzinfo.",
      "chains": {
        "utc": {
          "name": "datetime.timezone.utc",
          "type": "constant",
          "signature": null,
          "short_docstring": "Fixed offset from UTC implementation of tzinfo.",
          "value": "UTC"
        }
      }
    },
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "fromtimestamp": {
          "name": "datetime.datetime.fromtimestamp",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "timestamp[, tz] -> tz's local time from POSIX timestamp."
        }
      }
    },
    "entry.name": {
      "name": "entry.name",
      "error": "Import error: No module named 'entry'"
    },
    "entry.path": {
      "name": "entry.path",
      "error": "Import error: No module named 'entry'"
    },
    "entry.is_file()": {
      "name": "entry.is_file()",
      "error": "Import error: No module named 'entry'"
    },
    "file_details.append((entry.name, file_size, creation_time, modification_time))": {
      "name": "file_details.append((entry.name, file_size, creation_time, modification_time))",
      "error": "Import error: No module named 'file_details'"
    },
    "os.stat.st_size": {
      "name": "os.stat.st_size",
      "type": "callable",
      "signature": "(path, *, dir_fd=None, follow_symlinks=True)",
      "short_docstring": "Perform a stat system call on the given path."
    },
    "os.stat.st_ctime": {
      "name": "os.stat.st_ctime",
      "type": "callable",
      "signature": "(path, *, dir_fd=None, follow_symlinks=True)",
      "short_docstring": "Perform a stat system call on the given path."
    },
    "os.stat.st_mtime": {
      "name": "os.stat.st_mtime",
      "type": "callable",
      "signature": "(path, *, dir_fd=None, follow_symlinks=True)",
      "short_docstring": "Perform a stat system call on the given path."
    },
    "os.stat": {
      "name": "os.stat",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Perform a stat system call on the given path."
    },
    "os.scandir": {
      "name": "os.scandir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return an iterator of DirEntry objects for given path."
    }
  },
  "BigCodeBench/985": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "to_csv": {
          "name": "pandas.DataFrame.to_csv",
          "type": "callable",
          "signature": "(self, path_or_buf: 'FilePath | WriteBuffer[bytes] | WriteBuffer[str] | None' = None, index: 'bool_t' = True)",
          "short_docstring": "Write object to a comma-separated values (csv) file."
        }
      }
    },
    "data.get.items()": {
      "name": "data.get.items()",
      "error": "Import error: No module named 'data'"
    },
    "json.loads": {
      "name": "json.loads",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object."
    },
    "json.loads.get": {
      "name": "json.loads.get",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object."
    },
    "math.floor": {
      "name": "math.floor",
      "type": "callable",
      "signature": "(x)",
      "short_docstring": "Return the floor of x as an Integral."
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name, exist_ok=False)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    }
  },
  "BigCodeBench/988": {
    "os.listdir": {
      "name": "os.listdir",
      "type": "callable",
      "signature": "(path=None)",
      "short_docstring": "Return a list containing the names of the files in the directory."
    },
    "os.path.isdir": {
      "name": "os.path.isdir",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Return true if the pathname refers to an existing directory."
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "predicate_functions.items()": {
      "name": "predicate_functions.items()",
      "error": "Import error: No module named 'predicate_functions'"
    },
    "re.search": {
      "name": "re.search",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Scan through string looking for a match to the pattern, returning\na Match object, or None if no match was found."
    },
    "x.name": {
      "name": "x.name",
      "error": "Import error: No module named 'x'"
    },
    "x.stem": {
      "name": "x.stem",
      "error": "Import error: No module named 'x'"
    },
    "x.is_dir()": {
      "name": "x.is_dir()",
      "error": "Import error: No module named 'x'"
    },
    "x.is_file()": {
      "name": "x.is_file()",
      "error": "Import error: No module named 'x'"
    }
  },
  "BigCodeBench/990": {
    "base64.b64encode": {
      "name": "base64.b64encode",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Encode the bytes-like object s using Base64 and return a bytes object."
    },
    "binascii.hexlify": {
      "name": "binascii.hexlify",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Hexadecimal representation of binary data."
    },
    "bytes.fromhex(hex_string)": {
      "name": "bytes.fromhex(hex_string)",
      "error": "Import error: No module named 'bytes'"
    },
    "bytes.fromhex.decode.encode()": {
      "name": "bytes.fromhex.decode.encode()",
      "error": "Import error: No module named 'bytes'"
    },
    "bytes.fromhex.decode.encode('ascii')": {
      "name": "bytes.fromhex.decode.encode('ascii')",
      "error": "Import error: No module named 'bytes'"
    },
    "bytes.fromhex.decode.encode('utf-8')": {
      "name": "bytes.fromhex.decode.encode('utf-8')",
      "error": "Import error: No module named 'bytes'"
    },
    "bytes.fromhex.decode.encode('utf-16')": {
      "name": "bytes.fromhex.decode.encode('utf-16')",
      "error": "Import error: No module named 'bytes'"
    },
    "bytes.fromhex.decode.encode('utf-32')": {
      "name": "bytes.fromhex.decode.encode('utf-32')",
      "error": "Import error: No module named 'bytes'"
    },
    "codecs.encode": {
      "name": "codecs.encode",
      "type": "callable",
      "signature": "(obj, encoding='utf-8')",
      "short_docstring": "Encodes obj using the codec registered for encoding."
    },
    "urllib.parse.quote": {
      "name": "urllib.parse.quote",
      "type": "callable",
      "signature": "(string)",
      "short_docstring": "quote('abc def') -> 'abc%20def'"
    }
  },
  "BigCodeBench/998": {
    "hashlib.md5": {
      "name": "hashlib.md5",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Returns a md5 hash object; optionally initialized with a string"
    },
    "hashlib.md5.hexdigest": {
      "name": "hashlib.md5.hexdigest",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Returns a md5 hash object; optionally initialized with a string"
    },
    "hashlib.md5.update": {
      "name": "hashlib.md5.update",
      "type": "callable",
      "signature": "(string=b'')",
      "short_docstring": "Returns a md5 hash object; optionally initialized with a string"
    },
    "open.read(4096)": {
      "name": "open.read(4096)",
      "error": "Import error: No module named 'open'"
    },
    "os.remove": {
      "name": "os.remove",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Remove a file (same as unlink())."
    },
    "tarfile.open.extractall": {
      "name": "tarfile.open.extractall",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Open a tar archive for reading, writing or appending. Return\nan appropriate TarFile class."
    },
    "tarfile.open": {
      "name": "tarfile.open",
      "type": "callable",
      "signature": "(name=None, mode='r')",
      "short_docstring": "Open a tar archive for reading, writing or appending. Return\nan appropriate TarFile class."
    },
    "urllib.request.urlretrieve": {
      "name": "urllib.request.urlretrieve",
      "type": "callable",
      "signature": "(url, filename=None)",
      "short_docstring": "Retrieve a URL into a temporary location on disk."
    }
  },
  "BigCodeBench/999": {
    "csv.DictReader": {
      "name": "csv.DictReader",
      "type": "class",
      "signature": "(f, fieldnames=None, restkey=None, restval=None, dialect='excel', *args, **kwds)",
      "short_docstring": "",
      "chains": {
        "fieldnames": {
          "name": "csv.DictReader.fieldnames",
          "type": "constant",
          "signature": null,
          "short_docstring": "",
          "value": "<property object at 0x7f3ef5800090>"
        }
      }
    },
    "os.remove": {
      "name": "os.remove",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Remove a file (same as unlink())."
    },
    "urllib.request.urlretrieve": {
      "name": "urllib.request.urlretrieve",
      "type": "callable",
      "signature": "(url, filename=None)",
      "short_docstring": "Retrieve a URL into a temporary location on disk."
    }
  },
  "BigCodeBench/1003": {
    "child.tag": {
      "name": "child.tag",
      "error": "Import error: No module named 'child'"
    },
    "child.text": {
      "name": "child.text",
      "error": "Import error: No module named 'child'"
    },
    "data.append(data_item)": {
      "name": "data.append(data_item)",
      "error": "Import error: No module named 'data'"
    },
    "lxml.etree.XML": {
      "name": "lxml.etree.XML",
      "type": "callable",
      "signature": "(text)",
      "short_docstring": "XML(text, parser=None, base_url=None)"
    },
    "lxml.etree.XMLSyntaxError": {
      "name": "lxml.etree.XMLSyntaxError",
      "type": "class",
      "signature": "(message, code, line, column, filename=None)",
      "short_docstring": "Syntax error while parsing an XML document.\n    "
    },
    "lxml.etree.XML.findall": {
      "name": "lxml.etree.XML.findall",
      "type": "callable",
      "signature": "(text)",
      "short_docstring": "XML(text, parser=None, base_url=None)"
    },
    "urllib.request.urlopen": {
      "name": "urllib.request.urlopen",
      "type": "callable",
      "signature": "(url)",
      "short_docstring": "Open the URL url, which can be either a string or a Request object."
    },
    "urllib.request.urlopen.read": {
      "name": "urllib.request.urlopen.read",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Open the URL url, which can be either a string or a Request object."
    }
  },
  "BigCodeBench/1004": {
    "collections.Counter": {
      "name": "collections.Counter",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "short_docstring": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.",
      "chains": {
        "most_common": {
          "name": "collections.Counter.most_common",
          "type": "callable",
          "signature": "(self, n=None)",
          "short_docstring": "List the n most common elements and their counts from the most\ncommon to the least.  If n is None, then list all element counts."
        }
      }
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].set_xlabel": {
      "name": "matplotlib.pyplot.subplots[1].set_xlabel",
      "type": "method",
      "signature": "(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the x-axis."
    },
    "matplotlib.pyplot.subplots[1].set_ylabel": {
      "name": "matplotlib.pyplot.subplots[1].set_ylabel",
      "type": "method",
      "signature": "(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)",
      "short_docstring": "Set the label for the y-axis."
    },
    "matplotlib.pyplot.subplots[1].set_title": {
      "name": "matplotlib.pyplot.subplots[1].set_title",
      "type": "method",
      "signature": "(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)",
      "short_docstring": "Set a title for the Axes."
    },
    "matplotlib.pyplot.subplots[1].bar": {
      "name": "matplotlib.pyplot.subplots[1].bar",
      "type": "method",
      "signature": "(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)",
      "short_docstring": "Make a bar plot."
    },
    "re.findall": {
      "name": "re.findall",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Return a list of all non-overlapping matches in the string."
    },
    "urllib.request.urlopen": {
      "name": "urllib.request.urlopen",
      "type": "callable",
      "signature": "(url)",
      "short_docstring": "Open the URL url, which can be either a string or a Request object."
    },
    "urllib.request.urlopen.read": {
      "name": "urllib.request.urlopen.read",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Open the URL url, which can be either a string or a Request object."
    }
  },
  "BigCodeBench/1006": {
    "zipfile.ZipFile": {
      "name": "zipfile.ZipFile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "short_docstring": "Class with methods to open, read, write, close, list zip files.",
      "chains": {
        "extractall": {
          "name": "zipfile.ZipFile.extractall",
          "type": "callable",
          "signature": "(self, path=None)",
          "short_docstring": "Extract all members from the archive to the current working\ndirectory. `path' specifies a different directory to extract to.\n`members' is optional and must be a subset of the list returned\nby namelist()."
        }
      }
    },
    "open.write(response.content)": {
      "name": "open.write(response.content)",
      "error": "Import error: No module named 'open'"
    },
    "os.path.basename": {
      "name": "os.path.basename",
      "type": "callable",
      "signature": "(p)",
      "short_docstring": "Returns the final component of a pathname"
    },
    "os.makedirs": {
      "name": "os.makedirs",
      "type": "callable",
      "signature": "(name)",
      "short_docstring": "makedirs(name [, mode=0o777][, exist_ok=False])"
    },
    "os.path.splitext": {
      "name": "os.path.splitext",
      "type": "callable",
      "signature": "(p)",
      "short_docstring": "Split the extension from a pathname."
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "requests.get.headers": {
      "name": "requests.get.headers",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get.content": {
      "name": "requests.get.content",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get.raise_for_status": {
      "name": "requests.get.raise_for_status",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Sends a GET request."
    },
    "requests.get.headers.get": {
      "name": "requests.get.headers.get",
      "type": "callable",
      "signature": "(url, params=None)",
      "short_docstring": "Sends a GET request."
    }
  },
  "BigCodeBench/1008": {
    "bs4.BeautifulSoup": {
      "name": "bs4.BeautifulSoup",
      "type": "class",
      "signature": "(markup='', features=None, builder=None, parse_only=None, from_encoding=None, exclude_encodings=None, element_classes=None, **kwargs)",
      "short_docstring": "A data structure representing a parsed HTML or XML document.",
      "chains": {
        "find": {
          "name": "bs4.BeautifulSoup.find",
          "type": "callable",
          "signature": "(self, name=None, attrs={})",
          "short_docstring": "Look in the children of this PageElement and find the first\nPageElement that matches the given criteria."
        }
      }
    },
    "pandas.read_html": {
      "name": "pandas.read_html",
      "type": "callable",
      "signature": "(io: 'FilePath | ReadBuffer[str]')",
      "short_docstring": "Read HTML tables into a ``list`` of ``DataFrame`` objects."
    },
    "requests.get.text": {
      "name": "requests.get.text",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.exceptions.HTTPError": {
      "name": "requests.exceptions.HTTPError",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "short_docstring": "An HTTP error occurred."
    },
    "requests.get.raise_for_status": {
      "name": "requests.get.raise_for_status",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Sends a GET request."
    },
    "soup.find.find_all('tr')": {
      "name": "soup.find.find_all('tr')",
      "error": "Import error: No module named 'soup'"
    }
  },
  "BigCodeBench/1012": {
    "zipfile.ZipFile": {
      "name": "zipfile.ZipFile",
      "type": "class",
      "signature": "(file, mode='r', compression=0, allowZip64=True, compresslevel=None, *, strict_timestamps=True)",
      "short_docstring": "Class with methods to open, read, write, close, list zip files.",
      "chains": {
        "extractall": {
          "name": "zipfile.ZipFile.extractall",
          "type": "callable",
          "signature": "(self, path=None)",
          "short_docstring": "Extract all members from the archive to the current working\ndirectory. `path' specifies a different directory to extract to.\n`members' is optional and must be a subset of the list returned\nby namelist()."
        }
      }
    },
    "file.name": {
      "name": "file.name",
      "error": "Import error: No module named 'file'"
    },
    "filepath.parent": {
      "name": "filepath.parent",
      "error": "Import error: No module named 'filepath'"
    },
    "filepath.parent.mkdir(parents=True, exist_ok=True)": {
      "name": "filepath.parent.mkdir(parents=True, exist_ok=True)",
      "error": "Import error: No module named 'filepath'"
    },
    "open.write(data)": {
      "name": "open.write(data)",
      "error": "Import error: No module named 'open'"
    },
    "requests.get.status_code": {
      "name": "requests.get.status_code",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get.iter_content": {
      "name": "requests.get.iter_content",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Sends a GET request."
    },
    "requests.exceptions.RequestException": {
      "name": "requests.exceptions.RequestException",
      "type": "class",
      "signature": "(*args, **kwargs)",
      "short_docstring": "There was an ambiguous exception that occurred while handling your\nrequest."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "zip_dir.iterdir()": {
      "name": "zip_dir.iterdir()",
      "error": "Import error: No module named 'zip_dir'"
    },
    "zip_dir.mkdir(parents=True, exist_ok=True)": {
      "name": "zip_dir.mkdir(parents=True, exist_ok=True)",
      "error": "Import error: No module named 'zip_dir'"
    }
  },
  "BigCodeBench/1013": {
    "bs4.BeautifulSoup": {
      "name": "bs4.BeautifulSoup",
      "type": "class",
      "signature": "(markup='', features=None, builder=None, parse_only=None, from_encoding=None, exclude_encodings=None, element_classes=None, **kwargs)",
      "short_docstring": "A data structure representing a parsed HTML or XML document.",
      "chains": {
        "find_all": {
          "name": "bs4.BeautifulSoup.find_all",
          "type": "callable",
          "signature": "(self, name=None, **kwargs)",
          "short_docstring": "Look in the children of this PageElement and find all\nPageElements that match the given criteria."
        }
      }
    },
    "csv.writer": {
      "name": "csv.writer",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "csv.writer.writerow": {
      "name": "csv.writer.writerow",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "csv_writer = csv.writer(fileobj [, dialect='excel']\n                            [optional keyword args])\n    for row in sequence:\n        csv_writer.writerow(row)"
    },
    "requests.get.text": {
      "name": "requests.get.text",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url)",
      "short_docstring": "Sends a GET request."
    },
    "urllib.parse.urljoin": {
      "name": "urllib.parse.urljoin",
      "type": "callable",
      "signature": "(base, url)",
      "short_docstring": "Join a base URL and a possibly relative URL to form an absolute\ninterpretation of the latter."
    }
  },
  "BigCodeBench/1015": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "empty": {
          "name": "pandas.DataFrame.empty",
          "type": "constant",
          "signature": null,
          "short_docstring": "Indicator whether Series/DataFrame is empty.",
          "value": "<property object at 0x7f3e4732bba0>"
        },
        "to_sql": {
          "name": "pandas.DataFrame.to_sql",
          "type": "callable",
          "signature": "(self, name: 'str', con, if_exists: \"Literal['fail', index: 'bool_t' = True)",
          "short_docstring": "Write records stored in a DataFrame to a SQL database."
        }
      }
    },
    "cell.text_content()": {
      "name": "cell.text_content()",
      "error": "Import error: No module named 'cell'"
    },
    "lxml.html.fromstring": {
      "name": "lxml.html.fromstring",
      "type": "callable",
      "signature": "(html)",
      "short_docstring": "Parse the html, returning a single element/document."
    },
    "lxml.html.fromstring.xpath": {
      "name": "lxml.html.fromstring.xpath",
      "type": "callable",
      "signature": "(html)",
      "short_docstring": "Parse the html, returning a single element/document."
    },
    "open.read()": {
      "name": "open.read()",
      "error": "Import error: No module named 'open'"
    },
    "requests.get.content": {
      "name": "requests.get.content",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get.raise_for_status": {
      "name": "requests.get.raise_for_status",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Sends a GET request."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "row.xpath('.//td')": {
      "name": "row.xpath('.//td')",
      "error": "Import error: No module named 'row'"
    },
    "sqlite3.connect.close": {
      "name": "sqlite3.connect.close",
      "type": "callable",
      "signature": "()",
      "short_docstring": "connect(database[, timeout, detect_types, isolation_level,\n        check_same_thread, factory, cached_statements, uri])"
    },
    "sqlite3.connect": {
      "name": "sqlite3.connect",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "connect(database[, timeout, detect_types, isolation_level,\n        check_same_thread, factory, cached_statements, uri])"
    },
    "webpage_url.startswith('file://')": {
      "name": "webpage_url.startswith('file://')",
      "error": "Import error: No module named 'webpage_url'"
    }
  },
  "BigCodeBench/1019": {
    "PIL.Image.open.info": {
      "name": "PIL.Image.open.info",
      "type": "callable",
      "signature": "(fp, mode='r', formats=None) -> 'Image'",
      "short_docstring": "Opens and identifies the given image file."
    },
    "PIL.Image.open": {
      "name": "PIL.Image.open",
      "type": "callable",
      "signature": "(fp)",
      "short_docstring": "Opens and identifies the given image file."
    },
    "PIL.Image.open.info.get": {
      "name": "PIL.Image.open.info.get",
      "type": "callable",
      "signature": "(fp, mode='r')",
      "short_docstring": "Opens and identifies the given image file."
    },
    "codecs.decode": {
      "name": "codecs.decode",
      "type": "callable",
      "signature": "(obj, encoding='utf-8')",
      "short_docstring": "Decodes obj using the codec registered for encoding."
    },
    "pytesseract.image_to_string": {
      "name": "pytesseract.image_to_string",
      "type": "callable",
      "signature": "(image)",
      "short_docstring": "Returns the result of a Tesseract OCR run on the provided image to string"
    },
    "pytesseract.image_to_string.encode": {
      "name": "pytesseract.image_to_string.encode",
      "type": "callable",
      "signature": "(image)",
      "short_docstring": "Returns the result of a Tesseract OCR run on the provided image to string"
    }
  },
  "BigCodeBench/1020": {
    "chardet.detect": {
      "name": "chardet.detect",
      "type": "callable",
      "signature": "(byte_str: Union[bytes)",
      "short_docstring": "Detect the encoding of the given byte string."
    },
    "content.decode.decode(from_encoding)": {
      "name": "content.decode.decode(from_encoding)",
      "error": "Import error: No module named 'content'"
    },
    "content.decode.decode(detected_encoding)": {
      "name": "content.decode.decode(detected_encoding)",
      "error": "Import error: No module named 'content'"
    },
    "content.encode(to_encoding).decode.encode(to_encoding)": {
      "name": "content.encode(to_encoding).decode.encode(to_encoding)",
      "error": "Import error: No module named 'decode'"
    },
    "json.loads": {
      "name": "json.loads",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object."
    },
    "requests.get.content": {
      "name": "requests.get.content",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url, **kwargs)",
      "short_docstring": "Sends a GET request."
    }
  },
  "BigCodeBench/1022": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "df.sort_values.sort_values(by=column_name)": {
      "name": "df.sort_values.sort_values(by=column_name)",
      "error": "Import error: No module named 'df'"
    },
    "os.path.isfile": {
      "name": "os.path.isfile",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path is a regular file"
    },
    "pandas.read_csv.columns": {
      "name": "pandas.read_csv.columns",
      "type": "callable",
      "signature": "(filepath_or_buffer: 'FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]', *, sep: 'str | None | lib.NoDefault' = <no_default>, delimiter: 'str | None | lib.NoDefault' = None, header: \"int | Sequence[int] | None | Literal['infer']\" = 'infer', names: 'Sequence[Hashable] | None | lib.NoDefault' = <no_default>, index_col: 'IndexLabel | Literal[False] | None' = None, usecols=None, dtype: 'DtypeArg | None' = None, engine: 'CSVEngine | None' = None, converters=None, true_values=None, false_values=None, skipinitialspace: 'bool' = False, skiprows=None, skipfooter: 'int' = 0, nrows: 'int | None' = None, na_values=None, keep_default_na: 'bool' = True, na_filter: 'bool' = True, verbose: 'bool' = False, skip_blank_lines: 'bool' = True, parse_dates: 'bool | Sequence[Hashable] | None' = None, infer_datetime_format: 'bool | lib.NoDefault' = <no_default>, keep_date_col: 'bool' = False, date_parser=<no_default>, date_format: 'str | None' = None, dayfirst: 'bool' = False, cache_dates: 'bool' = True, iterator: 'bool' = False, chunksize: 'int | None' = None, compression: 'CompressionOptions' = 'infer', thousands: 'str | None' = None, decimal: 'str' = '.', lineterminator: 'str | None' = None, quotechar: 'str' = '\"', quoting: 'int' = 0, doublequote: 'bool' = True, escapechar: 'str | None' = None, comment: 'str | None' = None, encoding: 'str | None' = None, encoding_errors: 'str | None' = 'strict', dialect: 'str | csv.Dialect | None' = None, on_bad_lines: 'str' = 'error', delim_whitespace: 'bool' = False, low_memory=True, memory_map: 'bool' = False, float_precision: \"Literal['high', 'legacy'] | None\" = None, storage_options: 'StorageOptions' = None, dtype_backend: 'DtypeBackend | lib.NoDefault' = <no_default>) -> 'DataFrame | TextFileReader'",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "pandas.read_csv": {
      "name": "pandas.read_csv",
      "type": "callable",
      "signature": "(filepath_or_buffer: 'FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]')",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "pandas.to_datetime": {
      "name": "pandas.to_datetime",
      "type": "callable",
      "signature": "(arg: 'DatetimeScalarOrArrayConvertible | DictConvertible', format: 'str | None' = None)",
      "short_docstring": "Convert argument to datetime."
    }
  },
  "BigCodeBench/1039": {
    "ssl.SSLContext": {
      "name": "ssl.SSLContext",
      "type": "class",
      "signature": "(protocol=None, *args, **kwargs)",
      "short_docstring": "An SSLContext holds various SSL-related configuration options and\ndata, such as certificates and possibly a private key.",
      "chains": {
        "wrap_socket": {
          "name": "ssl.SSLContext.wrap_socket",
          "type": "callable",
          "signature": "(self, sock, server_side=False)",
          "short_docstring": ""
        },
        "load_cert_chain": {
          "name": "ssl.SSLContext.load_cert_chain",
          "type": "callable",
          "signature": "(self, certfile, keyfile=None)",
          "short_docstring": ""
        }
      }
    },
    "context.wrap_socket.close()": {
      "name": "context.wrap_socket.close()",
      "error": "Import error: No module named 'context'"
    },
    "context.wrap_socket.recv(buffer_size)": {
      "name": "context.wrap_socket.recv(buffer_size)",
      "error": "Import error: No module named 'context'"
    },
    "context.wrap_socket.send(response.encode('utf-8'))": {
      "name": "context.wrap_socket.send(response.encode('utf-8'))",
      "error": "Import error: No module named 'context'"
    },
    "hashlib.sha256": {
      "name": "hashlib.sha256",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Returns a sha256 hash object; optionally initialized with a string"
    },
    "hashlib.sha256.hexdigest": {
      "name": "hashlib.sha256.hexdigest",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Returns a sha256 hash object; optionally initialized with a string"
    },
    "hashlib.sha256.update": {
      "name": "hashlib.sha256.update",
      "type": "callable",
      "signature": "(string=b'')",
      "short_docstring": "Returns a sha256 hash object; optionally initialized with a string"
    },
    "open.read(4096)": {
      "name": "open.read(4096)",
      "error": "Import error: No module named 'open'"
    },
    "os.path.exists": {
      "name": "os.path.exists",
      "type": "callable",
      "signature": "(path)",
      "short_docstring": "Test whether a path exists.  Returns False for broken symbolic links"
    },
    "sha256_hash.hexdigest.encode('utf-8')": {
      "name": "sha256_hash.hexdigest.encode('utf-8')",
      "error": "Import error: No module named 'sha256_hash'"
    },
    "ssl.PROTOCOL_TLS_SERVER": {
      "name": "ssl.PROTOCOL_TLS_SERVER",
      "type": "constant",
      "signature": null,
      "short_docstring": "An enumeration.",
      "value": "_SSLMethod.PROTOCOL_TLS_SERVER"
    }
  },
  "BigCodeBench/1040": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "socket.socket": {
      "name": "socket.socket",
      "type": "class",
      "signature": "(family=-1, type=-1, proto=-1, fileno=None)",
      "short_docstring": "A subclass of _socket.socket adding the makefile() method.",
      "chains": {
        "close": {
          "name": "socket.socket.close",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "close()"
        },
        "listen": {
          "name": "socket.socket.listen",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "listen([backlog])"
        },
        "setblocking": {
          "name": "socket.socket.setblocking",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "setblocking(flag)"
        },
        "bind": {
          "name": "socket.socket.bind",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "bind(address)"
        }
      }
    },
    "inputs.remove(s)": {
      "name": "inputs.remove(s)",
      "error": "Import error: No module named 'inputs'"
    },
    "inputs.append(connection)": {
      "name": "inputs.append(connection)",
      "error": "Import error: No module named 'inputs'"
    },
    "message_queues[s].get_nowait.encode": {
      "name": "message_queues[s].get_nowait.encode",
      "error": "No module named 'message_queues'"
    },
    "outputs.remove(s)": {
      "name": "outputs.remove(s)",
      "error": "Import error: No module named 'outputs'"
    },
    "outputs.append(s)": {
      "name": "outputs.append(s)",
      "error": "Import error: No module named 'outputs'"
    },
    "s.close()": {
      "name": "s.close()",
      "error": "Import error: No module named 's'"
    },
    "s.accept()": {
      "name": "s.accept()",
      "error": "Import error: No module named 's'"
    },
    "s.recv.decode()": {
      "name": "s.recv.decode()",
      "error": "Import error: No module named 's'"
    },
    "s.recv(buffer_size)": {
      "name": "s.recv(buffer_size)",
      "error": "Import error: No module named 's'"
    },
    "s.accept[0].setblocking": {
      "name": "s.accept[0].setblocking",
      "error": "No module named 's'"
    },
    "s.sendall(next_msg.encode('utf-8'))": {
      "name": "s.sendall(next_msg.encode('utf-8'))",
      "error": "Import error: No module named 's'"
    },
    "select.select": {
      "name": "select.select",
      "type": "callable",
      "signature": "(rlist, wlist, xlist, timeout=None)",
      "short_docstring": "Wait until one or more file descriptors are ready for some kind of I/O."
    },
    "socket.AF_INET": {
      "name": "socket.AF_INET",
      "type": "constant",
      "signature": null,
      "short_docstring": "An enumeration.",
      "value": "AddressFamily.AF_INET"
    },
    "socket.SOCK_STREAM": {
      "name": "socket.SOCK_STREAM",
      "type": "constant",
      "signature": null,
      "short_docstring": "An enumeration.",
      "value": "SocketKind.SOCK_STREAM"
    }
  },
  "BigCodeBench/1042": {
    "smtplib.SMTP": {
      "name": "smtplib.SMTP",
      "type": "class",
      "signature": "(host='', port=0, local_hostname=None, timeout=<object object at 0x7f3ef60c4b10>, source_address=None)",
      "short_docstring": "This class manages a connection to an SMTP or ESMTP server.\nSMTP Objects:\n    SMTP objects have the following attributes:\n        helo_resp\n            This is the message given by the server in response to the\n            most recent HELO command.",
      "chains": {
        "starttls": {
          "name": "smtplib.SMTP.starttls",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Puts the connection to the SMTP server into TLS mode."
        },
        "send_message": {
          "name": "smtplib.SMTP.send_message",
          "type": "callable",
          "signature": "(self, msg)",
          "short_docstring": "Converts message to a bytestring and passes it to sendmail."
        },
        "login": {
          "name": "smtplib.SMTP.login",
          "type": "callable",
          "signature": "(self, user, password)",
          "short_docstring": "Log in on an SMTP server that requires authentication."
        }
      }
    },
    "client_socket.close()": {
      "name": "client_socket.close()",
      "error": "Import error: No module named 'client_socket'"
    },
    "client_socket.recv(BUFFER_SIZE)": {
      "name": "client_socket.recv(BUFFER_SIZE)",
      "error": "Import error: No module named 'client_socket'"
    },
    "client_socket.send(response.encode('utf-8'))": {
      "name": "client_socket.send(response.encode('utf-8'))",
      "error": "Import error: No module named 'client_socket'"
    },
    "email.message.EmailMessage": {
      "name": "email.message.EmailMessage",
      "type": "class",
      "signature": "()",
      "short_docstring": "Basic message object."
    },
    "email.message.EmailMessage.set_content": {
      "name": "email.message.EmailMessage.set_content",
      "type": "callable",
      "signature": "(self, *args)",
      "short_docstring": ""
    },
    "getpass.getpass": {
      "name": "getpass.getpass",
      "type": "callable",
      "signature": "(prompt='Password: ')",
      "short_docstring": "Prompt for a password, with echo turned off."
    },
    "response.encode('utf-8')": {
      "name": "response.encode('utf-8')",
      "error": "Import error: No module named 'response'"
    }
  },
  "BigCodeBench/1053": {
    "pandas.DataFrame": {
      "name": "pandas.DataFrame",
      "type": "class",
      "signature": "(data=None, index: 'Axes | None' = None, columns: 'Axes | None' = None, dtype: 'Dtype | None' = None, copy: 'bool | None' = None) -> 'None'",
      "short_docstring": "Two-dimensional, size-mutable, potentially heterogeneous tabular data.",
      "chains": {
        "plot": {
          "name": "pandas.DataFrame.plot",
          "type": "class",
          "signature": "(data) -> 'None'",
          "short_docstring": "Make plots of Series or DataFrame."
        }
      }
    },
    "pandas.DataFrame.plot": {
      "name": "pandas.DataFrame.plot",
      "type": "class",
      "signature": "(data) -> 'None'",
      "short_docstring": "Make plots of Series or DataFrame.",
      "chains": {
        "bar": {
          "name": "pandas.DataFrame.plot.bar",
          "type": "callable",
          "signature": "(self, x=None, y=None, **kwargs) -> 'PlotAccessor)",
          "short_docstring": "Vertical bar plot."
        }
      }
    },
    "matplotlib.pyplot.close": {
      "name": "matplotlib.pyplot.close",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Close a figure window."
    },
    "matplotlib.pyplot.savefig": {
      "name": "matplotlib.pyplot.savefig",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "Save the current figure."
    },
    "pandas.read_csv": {
      "name": "pandas.read_csv",
      "type": "callable",
      "signature": "(filepath_or_buffer: 'FilePath | ReadCsvBuffer[bytes] | ReadCsvBuffer[str]', header: \"int | Sequence[int] | None | Literal['infer']\" = 'infer', names: 'Sequence[Hashable] | None | lib.NoDefault' = <no_default>, usecols=None)",
      "short_docstring": "Read a comma-separated values (csv) file into DataFrame."
    },
    "sklearn.feature_extraction.text.CountVectorizer.vocabulary_": {
      "name": "sklearn.feature_extraction.text.CountVectorizer.vocabulary_",
      "type": "class",
      "signature": "(*, input='content', encoding='utf-8', decode_error='strict', strip_accents=None, lowercase=True, preprocessor=None, tokenizer=None, stop_words=None, token_pattern='(?u)\\\\b\\\\w\\\\w+\\\\b', ngram_range=(1, 1), analyzer='word', max_df=1.0, min_df=1, max_features=None, vocabulary=None, binary=False, dtype=<class 'numpy.int64'>)",
      "short_docstring": "Convert a collection of text documents to a matrix of token counts."
    },
    "sklearn.feature_extraction.text.CountVectorizer.vocabulary_.items": {
      "name": "sklearn.feature_extraction.text.CountVectorizer.vocabulary_.items",
      "type": "class",
      "signature": "()",
      "short_docstring": "Convert a collection of text documents to a matrix of token counts."
    },
    "sklearn.feature_extraction.text.CountVectorizer": {
      "name": "sklearn.feature_extraction.text.CountVectorizer",
      "type": "class",
      "signature": "(stop_words=None)",
      "short_docstring": "Convert a collection of text documents to a matrix of token counts."
    },
    "sklearn.feature_extraction.text.CountVectorizer.fit_transform": {
      "name": "sklearn.feature_extraction.text.CountVectorizer.fit_transform",
      "type": "callable",
      "signature": "(self, raw_documents)",
      "short_docstring": "Learn the vocabulary dictionary and return document-term matrix."
    },
    "vectorizer.fit_transform.sum(axis=0)": {
      "name": "vectorizer.fit_transform.sum(axis=0)",
      "error": "Import error: No module named 'vectorizer'"
    }
  },
  "BigCodeBench/1057": {
    "numpy.array": {
      "name": "numpy.array",
      "type": "callable",
      "signature": "(*args, **kwargs)",
      "short_docstring": "array(object, dtype=None, *, copy=True, order='K', subok=False, ndmin=0,\n      like=None)"
    }
  },
  "BigCodeBench/1077": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "strptime": {
          "name": "datetime.datetime.strptime",
          "type": "callable",
          "signature": "(*args, **kwargs)",
          "short_docstring": "string, format -> new datetime parsed from a string (like time.strptime())."
        }
      }
    },
    "numpy.mean": {
      "name": "numpy.mean",
      "type": "callable",
      "signature": "(a)",
      "short_docstring": "Compute the arithmetic mean along the specified axis."
    },
    "pytz.UTC": {
      "name": "pytz.UTC",
      "type": "constant",
      "signature": null,
      "short_docstring": "UTC",
      "value": "UTC"
    },
    "pytz.timezone": {
      "name": "pytz.timezone",
      "type": "callable",
      "signature": "(zone)",
      "short_docstring": "Return a datetime.tzinfo implementation for the given timezone"
    }
  },
  "BigCodeBench/1085": {
    "collections.Counter": {
      "name": "collections.Counter",
      "type": "class",
      "signature": "(iterable=None, /, **kwds)",
      "short_docstring": "Dict subclass for counting hashable items.  Sometimes called a bag\nor multiset.  Elements are stored as dictionary keys and their counts\nare stored as dictionary values.",
      "chains": {
        "most_common": {
          "name": "collections.Counter.most_common",
          "type": "callable",
          "signature": "(self, n=None)",
          "short_docstring": "List the n most common elements and their counts from the most\ncommon to the least.  If n is None, then list all element counts."
        }
      }
    },
    "matplotlib.pyplot.subplots": {
      "name": "matplotlib.pyplot.subplots",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Create a figure and a set of subplots."
    },
    "matplotlib.pyplot.subplots[1].bar": {
      "name": "matplotlib.pyplot.subplots[1].bar",
      "type": "method",
      "signature": "(x, height, width=0.8, bottom=None, *, align='center', data=None, **kwargs)",
      "short_docstring": "Make a bar plot."
    },
    "re.sub": {
      "name": "re.sub",
      "type": "callable",
      "signature": "(pattern, repl, string)",
      "short_docstring": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used."
    },
    "re.sub.lower.split": {
      "name": "re.sub.lower.split",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Return the string obtained by replacing the leftmost\nnon-overlapping occurrences of the pattern in string by the\nreplacement repl.  repl can be either a string or a callable;\nif a string, backslash escapes in it are processed.  If it is\na callable, it's passed the Match object and must return\na replacement string to be used."
    }
  },
  "BigCodeBench/1124": {
    "bs4.BeautifulSoup": {
      "name": "bs4.BeautifulSoup",
      "type": "class",
      "signature": "(markup='', features=None, builder=None, parse_only=None, from_encoding=None, exclude_encodings=None, element_classes=None, **kwargs)",
      "short_docstring": "A data structure representing a parsed HTML or XML document.",
      "chains": {
        "title": {
          "name": "bs4.BeautifulSoup.title",
          "type": "class",
          "signature": "(markup='', features=None, builder=None, parse_only=None, from_encoding=None, exclude_encodings=None, element_classes=None, **kwargs)",
          "short_docstring": "A data structure representing a parsed HTML or XML document."
        }
      }
    },
    "re.search.group": {
      "name": "re.search.group",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Scan through string looking for a match to the pattern, returning\na Match object, or None if no match was found."
    },
    "re.search": {
      "name": "re.search",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Scan through string looking for a match to the pattern, returning\na Match object, or None if no match was found."
    },
    "requests.get.text": {
      "name": "requests.get.text",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get.raise_for_status": {
      "name": "requests.get.raise_for_status",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Sends a GET request."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "title.string": {
      "name": "title.string",
      "error": "Import error: No module named 'title'"
    },
    "urllib.parse.urlparse": {
      "name": "urllib.parse.urlparse",
      "type": "callable",
      "signature": "(url)",
      "short_docstring": "Parse a URL into 6 components:\n<scheme>://<netloc>/<path>;<params>?<query>#<fragment>"
    }
  },
  "BigCodeBench/1129": {
    "datetime.datetime": {
      "name": "datetime.datetime",
      "type": "class",
      "signature": "(self, /, *args, **kwargs)",
      "short_docstring": "datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]])",
      "chains": {
        "now": {
          "name": "datetime.datetime.now",
          "type": "callable",
          "signature": "()",
          "short_docstring": "Returns new datetime object representing current time local to tz."
        }
      }
    },
    "json.loads": {
      "name": "json.loads",
      "type": "callable",
      "signature": "(s)",
      "short_docstring": "Deserialize ``s`` (a ``str``, ``bytes`` or ``bytearray`` instance\ncontaining a JSON document) to a Python object."
    },
    "open.write(response.content)": {
      "name": "open.write(response.content)",
      "error": "Import error: No module named 'open'"
    },
    "os.getcwd": {
      "name": "os.getcwd",
      "type": "callable",
      "signature": "()",
      "short_docstring": "Return a unicode string representing the current working directory."
    },
    "os.path.join": {
      "name": "os.path.join",
      "type": "callable",
      "signature": "(a, *p)",
      "short_docstring": "Join two or more pathname components, inserting '/' as needed.\nIf any component is an absolute path, all previous path components\nwill be discarded.  An empty last part will result in a path that\nends with a separator."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get.content": {
      "name": "requests.get.content",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    }
  },
  "BigCodeBench/1137": {
    "bs4.BeautifulSoup": {
      "name": "bs4.BeautifulSoup",
      "type": "class",
      "signature": "(markup='', features=None, builder=None, parse_only=None, from_encoding=None, exclude_encodings=None, element_classes=None, **kwargs)",
      "short_docstring": "A data structure representing a parsed HTML or XML document.",
      "chains": {
        "get_text": {
          "name": "bs4.BeautifulSoup.get_text",
          "type": "callable",
          "signature": "(self)",
          "short_docstring": "Get all child strings, concatenated using the given separator."
        }
      }
    },
    "json.dump": {
      "name": "json.dump",
      "type": "callable",
      "signature": "(obj, fp)",
      "short_docstring": "Serialize ``obj`` as a JSON formatted stream to ``fp`` (a\n``.write()``-supporting file-like object)."
    },
    "open.read()": {
      "name": "open.read()",
      "error": "Import error: No module named 'open'"
    },
    "re.findall": {
      "name": "re.findall",
      "type": "callable",
      "signature": "(pattern, string)",
      "short_docstring": "Return a list of all non-overlapping matches in the string."
    },
    "requests.get.text": {
      "name": "requests.get.text",
      "type": "callable",
      "signature": "(url, params=None, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "requests.get": {
      "name": "requests.get",
      "type": "callable",
      "signature": "(url, **kwargs)",
      "short_docstring": "Sends a GET request."
    },
    "url.startswith('file://')": {
      "name": "url.startswith('file://')",
      "error": "Import error: No module named 'url'"
    }
  }
}